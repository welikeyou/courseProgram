/*
 * This file was automatically generated by EvoSuite
 * Sat Apr 27 03:45:41 GMT 2019
 */

package org.apache.commons.collections4.functors;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.shaded.org.mockito.Mockito.*;
import static org.evosuite.runtime.EvoAssertions.*;
import java.lang.reflect.Array;
import java.util.Collection;
import java.util.Comparator;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.Map;
import org.apache.commons.collections4.Closure;
import org.apache.commons.collections4.Factory;
import org.apache.commons.collections4.Predicate;
import org.apache.commons.collections4.Transformer;
import org.apache.commons.collections4.functors.AllPredicate;
import org.apache.commons.collections4.functors.AndPredicate;
import org.apache.commons.collections4.functors.AnyPredicate;
import org.apache.commons.collections4.functors.ChainedClosure;
import org.apache.commons.collections4.functors.ComparatorPredicate;
import org.apache.commons.collections4.functors.ConstantFactory;
import org.apache.commons.collections4.functors.DefaultEquator;
import org.apache.commons.collections4.functors.EqualPredicate;
import org.apache.commons.collections4.functors.ExceptionClosure;
import org.apache.commons.collections4.functors.ExceptionPredicate;
import org.apache.commons.collections4.functors.ExceptionTransformer;
import org.apache.commons.collections4.functors.FactoryTransformer;
import org.apache.commons.collections4.functors.FalsePredicate;
import org.apache.commons.collections4.functors.ForClosure;
import org.apache.commons.collections4.functors.IdentityPredicate;
import org.apache.commons.collections4.functors.IfClosure;
import org.apache.commons.collections4.functors.IfTransformer;
import org.apache.commons.collections4.functors.InstanceofPredicate;
import org.apache.commons.collections4.functors.InvokerTransformer;
import org.apache.commons.collections4.functors.MapTransformer;
import org.apache.commons.collections4.functors.NOPClosure;
import org.apache.commons.collections4.functors.NOPTransformer;
import org.apache.commons.collections4.functors.NonePredicate;
import org.apache.commons.collections4.functors.NotNullPredicate;
import org.apache.commons.collections4.functors.NotPredicate;
import org.apache.commons.collections4.functors.NullIsFalsePredicate;
import org.apache.commons.collections4.functors.NullIsTruePredicate;
import org.apache.commons.collections4.functors.NullPredicate;
import org.apache.commons.collections4.functors.OrPredicate;
import org.apache.commons.collections4.functors.SwitchClosure;
import org.apache.commons.collections4.functors.TransformedPredicate;
import org.apache.commons.collections4.functors.TransformerClosure;
import org.apache.commons.collections4.functors.TruePredicate;
import org.apache.commons.collections4.functors.UniquePredicate;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.ViolatedAssumptionAnswer;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true, useJEE = true) 
public class SwitchClosure_ESTest extends SwitchClosure_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void test00()  throws Throwable  {
      Predicate<Object>[] predicateArray0 = (Predicate<Object>[]) Array.newInstance(Predicate.class, 6);
      UniquePredicate<Object> uniquePredicate0 = new UniquePredicate<Object>();
      OrPredicate<Object> orPredicate0 = new OrPredicate<Object>(uniquePredicate0, uniquePredicate0);
      NotPredicate<Object> notPredicate0 = new NotPredicate<Object>(orPredicate0);
      predicateArray0[0] = (Predicate<Object>) notPredicate0;
      predicateArray0[1] = (Predicate<Object>) notPredicate0;
      Transformer<Object, Integer> transformer0 = InvokerTransformer.invokerTransformer("The predicate and closure arrays must be the same size");
      TransformedPredicate<Object> transformedPredicate0 = new TransformedPredicate<Object>(transformer0, notPredicate0);
      predicateArray0[2] = (Predicate<Object>) transformedPredicate0;
      predicateArray0[3] = (Predicate<Object>) transformedPredicate0;
      predicateArray0[4] = (Predicate<Object>) uniquePredicate0;
      predicateArray0[5] = predicateArray0[2];
      Closure<Object>[] closureArray0 = (Closure<Object>[]) Array.newInstance(Closure.class, 3);
      ChainedClosure<Object> chainedClosure0 = new ChainedClosure<Object>(closureArray0);
      closureArray0[0] = (Closure<Object>) chainedClosure0;
      closureArray0[1] = closureArray0[0];
      closureArray0[2] = closureArray0[0];
      IfClosure<Object> ifClosure0 = new IfClosure<Object>(orPredicate0, closureArray0[0], chainedClosure0);
      // Undeclared exception!
      try { 
        SwitchClosure.switchClosure((Predicate<? super ExceptionPredicate<ComparatorPredicate>>[]) predicateArray0, (Closure<? super ExceptionPredicate<ComparatorPredicate>>[]) closureArray0, (Closure<? super ExceptionPredicate<ComparatorPredicate>>) ifClosure0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // The predicate and closure arrays must be the same size
         //
         verifyException("org.apache.commons.collections4.functors.SwitchClosure", e);
      }
  }

  @Test(timeout = 4000)
  public void test01()  throws Throwable  {
      Predicate<Object>[] predicateArray0 = (Predicate<Object>[]) Array.newInstance(Predicate.class, 1);
      Predicate<Object> predicate0 = NullPredicate.nullPredicate();
      predicateArray0[0] = predicate0;
      Closure<Object>[] closureArray0 = (Closure<Object>[]) Array.newInstance(Closure.class, 1);
      LinkedList<Closure<Object>> linkedList0 = new LinkedList<Closure<Object>>();
      Closure<Object> closure0 = ChainedClosure.chainedClosure((Collection<? extends Closure<? super Object>>) linkedList0);
      SwitchClosure<IfClosure<InstanceofPredicate>> switchClosure0 = new SwitchClosure<IfClosure<InstanceofPredicate>>(predicateArray0, closureArray0, closure0);
      IfClosure<InstanceofPredicate> ifClosure0 = new IfClosure<InstanceofPredicate>(predicate0, closure0, closure0);
      switchClosure0.execute(ifClosure0);
  }

  @Test(timeout = 4000)
  public void test02()  throws Throwable  {
      HashMap<Predicate<Object>, Closure<Object>> hashMap0 = new HashMap<Predicate<Object>, Closure<Object>>();
      Closure<Object> closure0 = SwitchClosure.switchClosure((Map<Predicate<Object>, Closure<Object>>) hashMap0);
      Predicate<Object>[] predicateArray0 = (Predicate<Object>[]) Array.newInstance(Predicate.class, 6);
      Predicate<Object> predicate0 = FalsePredicate.falsePredicate();
      predicateArray0[0] = predicate0;
      Comparator<Object> comparator0 = (Comparator<Object>) mock(Comparator.class, new ViolatedAssumptionAnswer());
      doReturn(0).when(comparator0).compare(any() , any());
      ComparatorPredicate.Criterion comparatorPredicate_Criterion0 = ComparatorPredicate.Criterion.LESS;
      ComparatorPredicate<Object> comparatorPredicate0 = new ComparatorPredicate<Object>(closure0, comparator0, comparatorPredicate_Criterion0);
      predicateArray0[1] = (Predicate<Object>) comparatorPredicate0;
      Predicate<Object> predicate1 = NullIsTruePredicate.nullIsTruePredicate((Predicate<? super Object>) predicate0);
      predicateArray0[2] = predicate1;
      Closure<Object>[] closureArray0 = (Closure<Object>[]) Array.newInstance(Closure.class, 6);
      closureArray0[2] = closure0;
      SwitchClosure<IfClosure<Object>> switchClosure0 = new SwitchClosure<IfClosure<Object>>(predicateArray0, closureArray0, closure0);
      switchClosure0.execute((IfClosure<Object>) null);
  }

  @Test(timeout = 4000)
  public void test03()  throws Throwable  {
      Closure<Object>[] closureArray0 = (Closure<Object>[]) Array.newInstance(Closure.class, 0);
      Closure<Object> closure0 = ChainedClosure.chainedClosure((Closure<? super Object>[]) closureArray0);
      SwitchClosure<TransformerClosure<InstanceofPredicate>> switchClosure0 = new SwitchClosure<TransformerClosure<InstanceofPredicate>>((Predicate<? super TransformerClosure<InstanceofPredicate>>[]) null, closureArray0, closure0);
      Predicate<? super TransformerClosure<InstanceofPredicate>>[] predicateArray0 = switchClosure0.getPredicates();
      assertNull(predicateArray0);
  }

  @Test(timeout = 4000)
  public void test04()  throws Throwable  {
      Predicate<Object>[] predicateArray0 = (Predicate<Object>[]) Array.newInstance(Predicate.class, 0);
      Closure<Object>[] closureArray0 = (Closure<Object>[]) Array.newInstance(Closure.class, 4);
      Closure<Object> closure0 = ExceptionClosure.exceptionClosure();
      ForClosure<Object> forClosure0 = new ForClosure<Object>(286, closure0);
      SwitchClosure<NOPClosure<Object>> switchClosure0 = new SwitchClosure<NOPClosure<Object>>(predicateArray0, closureArray0, forClosure0);
      Predicate<? super NOPClosure<Object>>[] predicateArray1 = switchClosure0.getPredicates();
      assertEquals(0, predicateArray1.length);
  }

  @Test(timeout = 4000)
  public void test05()  throws Throwable  {
      Predicate<Object>[] predicateArray0 = (Predicate<Object>[]) Array.newInstance(Predicate.class, 0);
      HashMap<Predicate<Object>, Closure<Object>> hashMap0 = new HashMap<Predicate<Object>, Closure<Object>>();
      Closure<Object> closure0 = SwitchClosure.switchClosure((Map<Predicate<Object>, Closure<Object>>) hashMap0);
      SwitchClosure<AllPredicate<Object>> switchClosure0 = new SwitchClosure<AllPredicate<Object>>(predicateArray0, (Closure<? super AllPredicate<Object>>[]) null, closure0);
      Closure<? super AllPredicate<Object>>[] closureArray0 = switchClosure0.getClosures();
      assertNull(closureArray0);
  }

  @Test(timeout = 4000)
  public void test06()  throws Throwable  {
      Predicate<Object>[] predicateArray0 = (Predicate<Object>[]) Array.newInstance(Predicate.class, 9);
      Closure<Object>[] closureArray0 = (Closure<Object>[]) Array.newInstance(Closure.class, 0);
      SwitchClosure<SwitchClosure<InstanceofPredicate>> switchClosure0 = new SwitchClosure<SwitchClosure<InstanceofPredicate>>(predicateArray0, closureArray0, (Closure<? super SwitchClosure<InstanceofPredicate>>) null);
      Closure<? super SwitchClosure<InstanceofPredicate>>[] closureArray1 = switchClosure0.getClosures();
      assertEquals(0, closureArray1.length);
  }

  @Test(timeout = 4000)
  public void test07()  throws Throwable  {
      Predicate<Object>[] predicateArray0 = (Predicate<Object>[]) Array.newInstance(Predicate.class, 0);
      LinkedList<Closure<Object>> linkedList0 = new LinkedList<Closure<Object>>();
      Closure<Object> closure0 = ChainedClosure.chainedClosure((Collection<? extends Closure<? super Object>>) linkedList0);
      // Undeclared exception!
      try { 
        SwitchClosure.switchClosure((Predicate<? super NonePredicate<ExceptionPredicate>>[]) predicateArray0, (Closure<? super NonePredicate<ExceptionPredicate>>[]) null, (Closure<? super NonePredicate<ExceptionPredicate>>) closure0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // The closure array must not be null
         //
         verifyException("org.apache.commons.collections4.functors.FunctorUtils", e);
      }
  }

  @Test(timeout = 4000)
  public void test08()  throws Throwable  {
      Predicate<Object>[] predicateArray0 = (Predicate<Object>[]) Array.newInstance(Predicate.class, 4);
      Predicate<Object> predicate0 = NotNullPredicate.notNullPredicate();
      predicateArray0[0] = predicate0;
      AnyPredicate<Object> anyPredicate0 = new AnyPredicate<Object>(predicateArray0);
      predicateArray0[1] = (Predicate<Object>) anyPredicate0;
      Closure<Object>[] closureArray0 = (Closure<Object>[]) Array.newInstance(Closure.class, 3);
      SwitchClosure<EqualPredicate<Boolean>> switchClosure0 = new SwitchClosure<EqualPredicate<Boolean>>(predicateArray0, closureArray0, closureArray0[0]);
      // Undeclared exception!
      switchClosure0.execute((EqualPredicate<Boolean>) null);
  }

  @Test(timeout = 4000)
  public void test09()  throws Throwable  {
      Predicate<Integer>[] predicateArray0 = (Predicate<Integer>[]) Array.newInstance(Predicate.class, 4);
      AllPredicate<Integer> allPredicate0 = new AllPredicate<Integer>(predicateArray0);
      predicateArray0[0] = (Predicate<Integer>) allPredicate0;
      Predicate<Object>[] predicateArray1 = (Predicate<Object>[]) Array.newInstance(Predicate.class, 4);
      Predicate<Object> predicate0 = NotNullPredicate.notNullPredicate();
      predicateArray1[0] = predicate0;
      AnyPredicate<Object> anyPredicate0 = new AnyPredicate<Object>(predicateArray1);
      predicateArray1[1] = (Predicate<Object>) anyPredicate0;
      Class<Object> class0 = Object.class;
      InstanceofPredicate instanceofPredicate0 = new InstanceofPredicate(class0);
      EqualPredicate<Object> equalPredicate0 = new EqualPredicate<Object>(instanceofPredicate0);
      InstanceofPredicate.instanceOfPredicate(class0);
      predicateArray1[2] = (Predicate<Object>) equalPredicate0;
      Closure<Object>[] closureArray0 = (Closure<Object>[]) Array.newInstance(Closure.class, 3);
      Transformer<Object, Object> transformer0 = ExceptionTransformer.exceptionTransformer();
      Closure<Object> closure0 = TransformerClosure.transformerClosure((Transformer<? super Object, ?>) transformer0);
      closureArray0[0] = closure0;
      Closure<Object> closure1 = IfClosure.ifClosure((Predicate<? super Object>) equalPredicate0, (Closure<? super Object>) closure0);
      closureArray0[1] = closure1;
      Closure<Object> closure2 = ForClosure.forClosure(4, (Closure<? super Object>) closure1);
      closureArray0[2] = closure2;
      SwitchClosure<EqualPredicate<Boolean>> switchClosure0 = new SwitchClosure<EqualPredicate<Boolean>>(predicateArray1, closureArray0, closure1);
      // Undeclared exception!
      switchClosure0.execute((EqualPredicate<Boolean>) null);
  }

  @Test(timeout = 4000)
  public void test10()  throws Throwable  {
      Closure<Object>[] closureArray0 = (Closure<Object>[]) Array.newInstance(Closure.class, 1);
      ChainedClosure<Object> chainedClosure0 = new ChainedClosure<Object>(closureArray0);
      SwitchClosure<NotPredicate<Object>> switchClosure0 = new SwitchClosure<NotPredicate<Object>>((Predicate<? super NotPredicate<Object>>[]) null, closureArray0, chainedClosure0);
      Class<InstanceofPredicate> class0 = InstanceofPredicate.class;
      InstanceofPredicate instanceofPredicate0 = new InstanceofPredicate(class0);
      NotPredicate<Object> notPredicate0 = new NotPredicate<Object>(instanceofPredicate0);
      // Undeclared exception!
      try { 
        switchClosure0.execute(notPredicate0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.apache.commons.collections4.functors.SwitchClosure", e);
      }
  }

  @Test(timeout = 4000)
  public void test11()  throws Throwable  {
      Predicate<Object>[] predicateArray0 = (Predicate<Object>[]) Array.newInstance(Predicate.class, 5);
      Integer integer0 = new Integer(2);
      IdentityPredicate<Object> identityPredicate0 = new IdentityPredicate<Object>(integer0);
      predicateArray0[0] = (Predicate<Object>) identityPredicate0;
      Predicate<Object> predicate0 = TruePredicate.truePredicate();
      predicateArray0[1] = predicate0;
      Closure<Object>[] closureArray0 = (Closure<Object>[]) Array.newInstance(Closure.class, 1);
      SwitchClosure<ChainedClosure<String>> switchClosure0 = new SwitchClosure<ChainedClosure<String>>(predicateArray0, closureArray0, closureArray0[0]);
      ChainedClosure<String> chainedClosure0 = new ChainedClosure<String>(closureArray0);
      // Undeclared exception!
      try { 
        switchClosure0.execute(chainedClosure0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 1
         //
         verifyException("org.apache.commons.collections4.functors.SwitchClosure", e);
      }
  }

  @Test(timeout = 4000)
  public void test12()  throws Throwable  {
      Predicate<Object>[] predicateArray0 = (Predicate<Object>[]) Array.newInstance(Predicate.class, 4);
      Predicate<Object> predicate0 = UniquePredicate.uniquePredicate();
      NullIsFalsePredicate<Object> nullIsFalsePredicate0 = new NullIsFalsePredicate<Object>(predicate0);
      OrPredicate<Object> orPredicate0 = new OrPredicate<Object>(nullIsFalsePredicate0, predicate0);
      Predicate<Object> predicate1 = AndPredicate.andPredicate((Predicate<? super Object>) orPredicate0, (Predicate<? super Object>) predicate0);
      Predicate<Object> predicate2 = NullIsFalsePredicate.nullIsFalsePredicate((Predicate<? super Object>) predicate1);
      predicateArray0[0] = predicate2;
      predicateArray0[1] = (Predicate<Object>) nullIsFalsePredicate0;
      predicateArray0[2] = predicateArray0[1];
      predicateArray0[3] = predicateArray0[2];
      Closure<Object>[] closureArray0 = (Closure<Object>[]) Array.newInstance(Closure.class, 1);
      Transformer<Object, String> transformer0 = InvokerTransformer.invokerTransformer("org.apache.commons.collections4.functors.SwitchClosure");
      IfTransformer<Object, String> ifTransformer0 = new IfTransformer<Object, String>(predicate0, transformer0, transformer0);
      TransformerClosure<Object> transformerClosure0 = new TransformerClosure<Object>(ifTransformer0);
      SwitchClosure<InstanceofPredicate> switchClosure0 = new SwitchClosure<InstanceofPredicate>(predicateArray0, closureArray0, transformerClosure0);
      Class<InstanceofPredicate> class0 = InstanceofPredicate.class;
      InstanceofPredicate instanceofPredicate0 = new InstanceofPredicate(class0);
      // Undeclared exception!
      try { 
        switchClosure0.execute(instanceofPredicate0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // InvokerTransformer: The method 'org.apache.commons.collections4.functors.SwitchClosure' on 'class org.apache.commons.collections4.functors.InstanceofPredicate' does not exist
         //
         verifyException("org.apache.commons.collections4.functors.InvokerTransformer", e);
      }
  }

  @Test(timeout = 4000)
  public void test13()  throws Throwable  {
      HashMap<Predicate<IdentityPredicate<Integer>>, Closure<IdentityPredicate<Integer>>> hashMap0 = new HashMap<Predicate<IdentityPredicate<Integer>>, Closure<IdentityPredicate<Integer>>>();
      Integer integer0 = new Integer(3441);
      Factory<Integer> factory0 = ConstantFactory.constantFactory(integer0);
      FactoryTransformer<Object, Integer> factoryTransformer0 = new FactoryTransformer<Object, Integer>(factory0);
      Closure<IdentityPredicate<Integer>> closure0 = TransformerClosure.transformerClosure((Transformer<? super IdentityPredicate<Integer>, ?>) factoryTransformer0);
      hashMap0.put((Predicate<IdentityPredicate<Integer>>) null, closure0);
      Closure<IdentityPredicate<Integer>> closure1 = SwitchClosure.switchClosure((Map<Predicate<IdentityPredicate<Integer>>, Closure<IdentityPredicate<Integer>>>) hashMap0);
      assertSame(closure1, closure0);
  }

  @Test(timeout = 4000)
  public void test14()  throws Throwable  {
      HashMap<Predicate<IdentityPredicate<String>>, Closure<IdentityPredicate<String>>> hashMap0 = new HashMap<Predicate<IdentityPredicate<String>>, Closure<IdentityPredicate<String>>>();
      UniquePredicate<IdentityPredicate<String>> uniquePredicate0 = new UniquePredicate<IdentityPredicate<String>>();
      HashMap<Predicate<Object>, Closure<Object>> hashMap1 = new HashMap<Predicate<Object>, Closure<Object>>();
      Closure<Object> closure0 = SwitchClosure.switchClosure((Map<Predicate<Object>, Closure<Object>>) hashMap1);
      ForClosure<Object> forClosure0 = new ForClosure<Object>(2, closure0);
      IfClosure<IdentityPredicate<String>> ifClosure0 = new IfClosure<IdentityPredicate<String>>(uniquePredicate0, forClosure0);
      hashMap0.put(uniquePredicate0, ifClosure0);
      Closure<IdentityPredicate<String>> closure1 = SwitchClosure.switchClosure((Map<Predicate<IdentityPredicate<String>>, Closure<IdentityPredicate<String>>>) hashMap0);
      assertNotNull(closure1);
  }

  @Test(timeout = 4000)
  public void test15()  throws Throwable  {
      // Undeclared exception!
      try { 
        SwitchClosure.switchClosure((Map<Predicate<NotNullPredicate<NotNullPredicate>>, Closure<NotNullPredicate<NotNullPredicate>>>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // The predicate and closure map must not be null
         //
         verifyException("org.apache.commons.collections4.functors.SwitchClosure", e);
      }
  }

  @Test(timeout = 4000)
  public void test16()  throws Throwable  {
      Predicate<Object>[] predicateArray0 = (Predicate<Object>[]) Array.newInstance(Predicate.class, 1);
      DefaultEquator<Object> defaultEquator0 = DefaultEquator.defaultEquator();
      EqualPredicate<Object> equalPredicate0 = new EqualPredicate<Object>((Object) null, defaultEquator0);
      predicateArray0[0] = (Predicate<Object>) equalPredicate0;
      Closure<Object>[] closureArray0 = (Closure<Object>[]) Array.newInstance(Closure.class, 1);
      HashMap<Object, Object> hashMap0 = new HashMap<Object, Object>();
      Transformer<Object, Object> transformer0 = MapTransformer.mapTransformer((Map<? super Object, ?>) hashMap0);
      TransformerClosure<Object> transformerClosure0 = new TransformerClosure<Object>(transformer0);
      closureArray0[0] = (Closure<Object>) transformerClosure0;
      Closure<Object> closure0 = SwitchClosure.switchClosure((Predicate<? super Object>[]) predicateArray0, (Closure<? super Object>[]) closureArray0, (Closure<? super Object>) transformerClosure0);
      assertNotNull(closure0);
  }

  @Test(timeout = 4000)
  public void test17()  throws Throwable  {
      Predicate<Object>[] predicateArray0 = (Predicate<Object>[]) Array.newInstance(Predicate.class, 0);
      Closure<Object>[] closureArray0 = (Closure<Object>[]) Array.newInstance(Closure.class, 1);
      HashMap<Predicate<Object>, Closure<Object>> hashMap0 = new HashMap<Predicate<Object>, Closure<Object>>();
      Closure<Object> closure0 = SwitchClosure.switchClosure((Map<Predicate<Object>, Closure<Object>>) hashMap0);
      closureArray0[0] = closure0;
      // Undeclared exception!
      try { 
        SwitchClosure.switchClosure((Predicate<? super Object>[]) predicateArray0, (Closure<? super Object>[]) closureArray0, (Closure<? super Object>) closureArray0[0]);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // The predicate and closure arrays must be the same size
         //
         verifyException("org.apache.commons.collections4.functors.SwitchClosure", e);
      }
  }

  @Test(timeout = 4000)
  public void test18()  throws Throwable  {
      Closure<Object>[] closureArray0 = (Closure<Object>[]) Array.newInstance(Closure.class, 0);
      Predicate<Object>[] predicateArray0 = (Predicate<Object>[]) Array.newInstance(Predicate.class, 0);
      Transformer<Object, Object> transformer0 = NOPTransformer.nopTransformer();
      Closure<Object> closure0 = TransformerClosure.transformerClosure((Transformer<? super Object, ?>) transformer0);
      Closure<Object> closure1 = SwitchClosure.switchClosure((Predicate<? super Object>[]) predicateArray0, (Closure<? super Object>[]) closureArray0, (Closure<? super Object>) closure0);
      assertSame(closure1, closure0);
  }

  @Test(timeout = 4000)
  public void test19()  throws Throwable  {
      Predicate<Object>[] predicateArray0 = (Predicate<Object>[]) Array.newInstance(Predicate.class, 4);
      Predicate<Object> predicate0 = UniquePredicate.uniquePredicate();
      Closure<Object>[] closureArray0 = (Closure<Object>[]) Array.newInstance(Closure.class, 1);
      Transformer<Object, String> transformer0 = InvokerTransformer.invokerTransformer("org.apache.commons.collections4.functors.SwitchClosure");
      IfTransformer<Object, String> ifTransformer0 = new IfTransformer<Object, String>(predicate0, transformer0, transformer0);
      TransformerClosure<Object> transformerClosure0 = new TransformerClosure<Object>(ifTransformer0);
      SwitchClosure<NotNullPredicate<Integer>> switchClosure0 = new SwitchClosure<NotNullPredicate<Integer>>(predicateArray0, closureArray0, transformerClosure0);
      Closure<? super NotNullPredicate<Integer>>[] closureArray1 = switchClosure0.getClosures();
      assertEquals(1, closureArray1.length);
  }

  @Test(timeout = 4000)
  public void test20()  throws Throwable  {
      Predicate<Object>[] predicateArray0 = (Predicate<Object>[]) Array.newInstance(Predicate.class, 2);
      Closure<Object>[] closureArray0 = (Closure<Object>[]) Array.newInstance(Closure.class, 0);
      Transformer<Object, Object> transformer0 = NOPTransformer.nopTransformer();
      Closure<Object> closure0 = TransformerClosure.transformerClosure((Transformer<? super Object, ?>) transformer0);
      SwitchClosure<InstanceofPredicate> switchClosure0 = new SwitchClosure<InstanceofPredicate>(predicateArray0, closureArray0, closure0);
      Predicate<? super InstanceofPredicate>[] predicateArray1 = switchClosure0.getPredicates();
      assertEquals(2, predicateArray1.length);
  }

  @Test(timeout = 4000)
  public void test21()  throws Throwable  {
      HashMap<Predicate<Object>, Closure<Object>> hashMap0 = new HashMap<Predicate<Object>, Closure<Object>>();
      Closure<Object> closure0 = SwitchClosure.switchClosure((Map<Predicate<Object>, Closure<Object>>) hashMap0);
      Predicate<Object>[] predicateArray0 = (Predicate<Object>[]) Array.newInstance(Predicate.class, 5);
      Closure<Object>[] closureArray0 = (Closure<Object>[]) Array.newInstance(Closure.class, 1);
      SwitchClosure<TransformerClosure<Object>> switchClosure0 = new SwitchClosure<TransformerClosure<Object>>(predicateArray0, closureArray0, closure0);
      Closure<? super TransformerClosure<Object>> closure1 = switchClosure0.getDefaultClosure();
      assertNotNull(closure1);
  }
}
