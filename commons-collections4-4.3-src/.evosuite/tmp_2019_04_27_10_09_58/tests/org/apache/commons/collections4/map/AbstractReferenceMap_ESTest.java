/*
 * This file was automatically generated by EvoSuite
 * Sat Apr 27 03:14:31 GMT 2019
 */

package org.apache.commons.collections4.map;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.shaded.org.mockito.Mockito.*;
import static org.evosuite.runtime.EvoAssertions.*;
import java.io.BufferedInputStream;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.DataInputStream;
import java.io.InputStream;
import java.io.ObjectOutputStream;
import java.io.PipedInputStream;
import java.io.PipedOutputStream;
import java.io.PrintStream;
import java.io.PushbackInputStream;
import java.io.SequenceInputStream;
import java.lang.ref.PhantomReference;
import java.lang.ref.Reference;
import java.lang.ref.ReferenceQueue;
import java.lang.ref.SoftReference;
import java.lang.ref.WeakReference;
import java.lang.reflect.Array;
import java.util.AbstractMap;
import java.util.Collection;
import java.util.Comparator;
import java.util.Enumeration;
import java.util.Iterator;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Set;
import org.apache.commons.collections4.MapIterator;
import org.apache.commons.collections4.map.AbstractHashedMap;
import org.apache.commons.collections4.map.AbstractReferenceMap;
import org.apache.commons.collections4.map.ReferenceIdentityMap;
import org.apache.commons.collections4.map.ReferenceMap;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.ViolatedAssumptionAnswer;
import org.evosuite.runtime.mock.java.io.MockFileInputStream;
import org.evosuite.runtime.mock.java.io.MockPrintStream;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true, useJEE = true) 
public class AbstractReferenceMap_ESTest extends AbstractReferenceMap_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void test00()  throws Throwable  {
      AbstractReferenceMap.ReferenceStrength abstractReferenceMap_ReferenceStrength0 = AbstractReferenceMap.ReferenceStrength.WEAK;
      AbstractReferenceMap.ReferenceStrength abstractReferenceMap_ReferenceStrength1 = AbstractReferenceMap.ReferenceStrength.WEAK;
      ReferenceIdentityMap<AbstractReferenceMap.ReferenceEntry<Integer, Integer>, AbstractMap.SimpleEntry<Object, Integer>> referenceIdentityMap0 = new ReferenceIdentityMap<AbstractReferenceMap.ReferenceEntry<Integer, Integer>, AbstractMap.SimpleEntry<Object, Integer>>(abstractReferenceMap_ReferenceStrength0, abstractReferenceMap_ReferenceStrength1);
      assertNotNull(referenceIdentityMap0);
      
      ReferenceMap<Object, SequenceInputStream> referenceMap0 = new ReferenceMap<Object, SequenceInputStream>(abstractReferenceMap_ReferenceStrength0, abstractReferenceMap_ReferenceStrength1);
      assertNotNull(referenceMap0);
      
      Enumeration<InputStream> enumeration0 = (Enumeration<InputStream>) mock(Enumeration.class, new ViolatedAssumptionAnswer());
      doReturn(false).when(enumeration0).hasMoreElements();
      SequenceInputStream sequenceInputStream0 = new SequenceInputStream(enumeration0);
      assertNotNull(sequenceInputStream0);
      
      byte[] byteArray0 = new byte[6];
      byteArray0[0] = (byte)89;
      byteArray0[1] = (byte)100;
      byteArray0[2] = (byte) (-100);
      byteArray0[3] = (byte)3;
      byteArray0[4] = (byte) (-34);
      byteArray0[5] = (byte) (-41);
      int int0 = sequenceInputStream0.read(byteArray0, (-47), (int) (byte)3);
      assertEquals(6, byteArray0.length);
      assertArrayEquals(new byte[] {(byte)89, (byte)100, (byte) (-100), (byte)3, (byte) (-34), (byte) (-41)}, byteArray0);
      assertEquals((-1), int0);
      
      SequenceInputStream sequenceInputStream1 = referenceMap0.put(abstractReferenceMap_ReferenceStrength0, sequenceInputStream0);
      assertNull(sequenceInputStream1);
      assertSame(abstractReferenceMap_ReferenceStrength0, abstractReferenceMap_ReferenceStrength1);
      assertSame(abstractReferenceMap_ReferenceStrength1, abstractReferenceMap_ReferenceStrength0);
      
      referenceMap0.clear();
      assertSame(abstractReferenceMap_ReferenceStrength0, abstractReferenceMap_ReferenceStrength1);
      assertSame(abstractReferenceMap_ReferenceStrength1, abstractReferenceMap_ReferenceStrength0);
  }

  @Test(timeout = 4000)
  public void test01()  throws Throwable  {
      AbstractReferenceMap.ReferenceStrength abstractReferenceMap_ReferenceStrength0 = AbstractReferenceMap.ReferenceStrength.WEAK;
      AbstractReferenceMap.ReferenceStrength abstractReferenceMap_ReferenceStrength1 = AbstractReferenceMap.ReferenceStrength.HARD;
      ReferenceIdentityMap<AbstractReferenceMap.ReferenceEntry<String, Object>, Object> referenceIdentityMap0 = new ReferenceIdentityMap<AbstractReferenceMap.ReferenceEntry<String, Object>, Object>(abstractReferenceMap_ReferenceStrength0, abstractReferenceMap_ReferenceStrength1);
      assertFalse(abstractReferenceMap_ReferenceStrength0.equals((Object)abstractReferenceMap_ReferenceStrength1));
      assertFalse(abstractReferenceMap_ReferenceStrength1.equals((Object)abstractReferenceMap_ReferenceStrength0));
      assertNotNull(referenceIdentityMap0);
      
      AbstractReferenceMap.ReferenceKeySetIterator<AbstractReferenceMap.ReferenceEntry<String, Object>> abstractReferenceMap_ReferenceKeySetIterator0 = new AbstractReferenceMap.ReferenceKeySetIterator<AbstractReferenceMap.ReferenceEntry<String, Object>>(referenceIdentityMap0);
      assertFalse(abstractReferenceMap_ReferenceStrength0.equals((Object)abstractReferenceMap_ReferenceStrength1));
      assertFalse(abstractReferenceMap_ReferenceStrength1.equals((Object)abstractReferenceMap_ReferenceStrength0));
      assertNotNull(abstractReferenceMap_ReferenceKeySetIterator0);
      
      AbstractReferenceMap.ReferenceStrength abstractReferenceMap_ReferenceStrength2 = AbstractReferenceMap.ReferenceStrength.HARD;
      ReferenceIdentityMap<SequenceInputStream, Object> referenceIdentityMap1 = new ReferenceIdentityMap<SequenceInputStream, Object>(abstractReferenceMap_ReferenceStrength2, abstractReferenceMap_ReferenceStrength1);
      assertFalse(abstractReferenceMap_ReferenceStrength1.equals((Object)abstractReferenceMap_ReferenceStrength0));
      assertFalse(abstractReferenceMap_ReferenceStrength2.equals((Object)abstractReferenceMap_ReferenceStrength0));
      assertNotNull(referenceIdentityMap1);
      
      Enumeration<InputStream> enumeration0 = (Enumeration<InputStream>) mock(Enumeration.class, new ViolatedAssumptionAnswer());
      doReturn(false).when(enumeration0).hasMoreElements();
      SequenceInputStream sequenceInputStream0 = new SequenceInputStream(enumeration0);
      assertNotNull(sequenceInputStream0);
      
      byte[] byteArray0 = new byte[5];
      byteArray0[0] = (byte)2;
      byteArray0[1] = (byte)10;
      byteArray0[2] = (byte)1;
      byteArray0[3] = (byte) (-1);
      byteArray0[4] = (byte) (-71);
      int int0 = sequenceInputStream0.read(byteArray0, (int) (byte)2, (int) (byte) (-1));
      assertEquals(5, byteArray0.length);
      assertArrayEquals(new byte[] {(byte)2, (byte)10, (byte)1, (byte) (-1), (byte) (-71)}, byteArray0);
      assertEquals((-1), int0);
      
      int int1 = referenceIdentityMap1.hashEntry(sequenceInputStream0, referenceIdentityMap0);
      assertFalse(abstractReferenceMap_ReferenceStrength0.equals((Object)abstractReferenceMap_ReferenceStrength1));
      assertFalse(abstractReferenceMap_ReferenceStrength0.equals((Object)abstractReferenceMap_ReferenceStrength2));
      assertFalse(abstractReferenceMap_ReferenceStrength1.equals((Object)abstractReferenceMap_ReferenceStrength0));
      assertFalse(abstractReferenceMap_ReferenceStrength2.equals((Object)abstractReferenceMap_ReferenceStrength0));
      assertFalse(int1 == int0);
      assertEquals(5, int1);
      assertNotSame(abstractReferenceMap_ReferenceStrength0, abstractReferenceMap_ReferenceStrength1);
      assertNotSame(abstractReferenceMap_ReferenceStrength0, abstractReferenceMap_ReferenceStrength2);
      assertSame(abstractReferenceMap_ReferenceStrength1, abstractReferenceMap_ReferenceStrength2);
      assertNotSame(abstractReferenceMap_ReferenceStrength1, abstractReferenceMap_ReferenceStrength0);
      assertSame(abstractReferenceMap_ReferenceStrength2, abstractReferenceMap_ReferenceStrength1);
      assertNotSame(abstractReferenceMap_ReferenceStrength2, abstractReferenceMap_ReferenceStrength0);
  }

  @Test(timeout = 4000)
  public void test02()  throws Throwable  {
      ReferenceMap<SequenceInputStream, WeakReference<InputStream>> referenceMap0 = new ReferenceMap<SequenceInputStream, WeakReference<InputStream>>();
      assertNotNull(referenceMap0);
      
      Enumeration<InputStream> enumeration0 = (Enumeration<InputStream>) mock(Enumeration.class, new ViolatedAssumptionAnswer());
      doReturn(false).when(enumeration0).hasMoreElements();
      SequenceInputStream sequenceInputStream0 = new SequenceInputStream(enumeration0);
      assertNotNull(sequenceInputStream0);
      
      BufferedInputStream bufferedInputStream0 = new BufferedInputStream(sequenceInputStream0);
      assertNotNull(bufferedInputStream0);
      
      ReferenceQueue<Object> referenceQueue0 = new ReferenceQueue<Object>();
      assertNotNull(referenceQueue0);
      
      AbstractReferenceMap.WeakRef<InputStream> abstractReferenceMap_WeakRef0 = new AbstractReferenceMap.WeakRef<InputStream>((-1179), bufferedInputStream0, referenceQueue0);
      assertNotNull(abstractReferenceMap_WeakRef0);
      assertFalse(abstractReferenceMap_WeakRef0.isEnqueued());
      
      WeakReference<InputStream> weakReference0 = referenceMap0.put(sequenceInputStream0, abstractReferenceMap_WeakRef0);
      assertNull(weakReference0);
      assertFalse(abstractReferenceMap_WeakRef0.isEnqueued());
      
      AbstractReferenceMap.ReferenceEntrySetIterator<SequenceInputStream, WeakReference<InputStream>> abstractReferenceMap_ReferenceEntrySetIterator0 = new AbstractReferenceMap.ReferenceEntrySetIterator<SequenceInputStream, WeakReference<InputStream>>(referenceMap0);
      assertNotNull(abstractReferenceMap_ReferenceEntrySetIterator0);
      
      boolean boolean0 = abstractReferenceMap_ReferenceEntrySetIterator0.hasNext();
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void test03()  throws Throwable  {
      AbstractReferenceMap.ReferenceStrength abstractReferenceMap_ReferenceStrength0 = AbstractReferenceMap.ReferenceStrength.SOFT;
      AbstractReferenceMap.ReferenceStrength abstractReferenceMap_ReferenceStrength1 = AbstractReferenceMap.ReferenceStrength.HARD;
      ReferenceIdentityMap<String, SequenceInputStream> referenceIdentityMap0 = new ReferenceIdentityMap<String, SequenceInputStream>(abstractReferenceMap_ReferenceStrength0, abstractReferenceMap_ReferenceStrength1);
      assertFalse(abstractReferenceMap_ReferenceStrength0.equals((Object)abstractReferenceMap_ReferenceStrength1));
      assertFalse(abstractReferenceMap_ReferenceStrength1.equals((Object)abstractReferenceMap_ReferenceStrength0));
      assertNotNull(referenceIdentityMap0);
      
      AbstractHashedMap.HashEntry<String, SequenceInputStream> abstractHashedMap_HashEntry0 = referenceIdentityMap0.getEntry((Object) null);
      assertFalse(abstractReferenceMap_ReferenceStrength0.equals((Object)abstractReferenceMap_ReferenceStrength1));
      assertFalse(abstractReferenceMap_ReferenceStrength1.equals((Object)abstractReferenceMap_ReferenceStrength0));
      assertNull(abstractHashedMap_HashEntry0);
      assertNotSame(abstractReferenceMap_ReferenceStrength0, abstractReferenceMap_ReferenceStrength1);
      assertNotSame(abstractReferenceMap_ReferenceStrength1, abstractReferenceMap_ReferenceStrength0);
      
      int int0 = 2372;
      Enumeration<InputStream> enumeration0 = (Enumeration<InputStream>) mock(Enumeration.class, new ViolatedAssumptionAnswer());
      doReturn(false).when(enumeration0).hasMoreElements();
      SequenceInputStream sequenceInputStream0 = new SequenceInputStream(enumeration0);
      assertNotNull(sequenceInputStream0);
      
      AbstractHashedMap.HashEntry<String, SequenceInputStream> abstractHashedMap_HashEntry1 = new AbstractHashedMap.HashEntry<String, SequenceInputStream>((AbstractHashedMap.HashEntry<String, SequenceInputStream>) null, 2372, (Object) null, sequenceInputStream0);
      assertNotNull(abstractHashedMap_HashEntry1);
      
      SequenceInputStream sequenceInputStream1 = new SequenceInputStream(sequenceInputStream0, sequenceInputStream0);
      assertFalse(sequenceInputStream1.equals((Object)sequenceInputStream0));
      assertNotNull(sequenceInputStream1);
      
      AbstractReferenceMap.ReferenceEntry<String, SequenceInputStream> abstractReferenceMap_ReferenceEntry0 = new AbstractReferenceMap.ReferenceEntry<String, SequenceInputStream>(referenceIdentityMap0, abstractHashedMap_HashEntry1, 2372, "Q_#D*", sequenceInputStream1);
      assertFalse(abstractReferenceMap_ReferenceStrength0.equals((Object)abstractReferenceMap_ReferenceStrength1));
      assertFalse(abstractReferenceMap_ReferenceStrength1.equals((Object)abstractReferenceMap_ReferenceStrength0));
      assertFalse(sequenceInputStream0.equals((Object)sequenceInputStream1));
      assertFalse(sequenceInputStream1.equals((Object)sequenceInputStream0));
      assertNotNull(abstractReferenceMap_ReferenceEntry0);
      
      PipedInputStream pipedInputStream0 = new PipedInputStream();
      assertNotNull(pipedInputStream0);
      assertEquals(0, pipedInputStream0.available());
      
      boolean boolean0 = referenceIdentityMap0.equals(pipedInputStream0);
      assertFalse(abstractReferenceMap_ReferenceStrength0.equals((Object)abstractReferenceMap_ReferenceStrength1));
      assertFalse(abstractReferenceMap_ReferenceStrength1.equals((Object)abstractReferenceMap_ReferenceStrength0));
      assertFalse(boolean0);
      assertNotSame(abstractReferenceMap_ReferenceStrength0, abstractReferenceMap_ReferenceStrength1);
      assertNotSame(abstractReferenceMap_ReferenceStrength1, abstractReferenceMap_ReferenceStrength0);
      assertEquals(0, pipedInputStream0.available());
      
   //   Comparator<InputStream> comparator0 = (Comparator<InputStream>) mock(Comparator.class, new ViolatedAssumptionAnswer());
     // Comparator<Map.Entry<SequenceInputStream, Integer>> comparator1 = (Comparator<Map.Entry<SequenceInputStream, Integer>>)Map.Entry.comparingByKey((Comparator<? super SequenceInputStream>) comparator0);
      //assertNotNull(comparator1);
      
      abstractReferenceMap_ReferenceEntry0.nullValue();
      assertFalse(abstractReferenceMap_ReferenceStrength0.equals((Object)abstractReferenceMap_ReferenceStrength1));
      assertFalse(abstractReferenceMap_ReferenceStrength1.equals((Object)abstractReferenceMap_ReferenceStrength0));
      assertFalse(sequenceInputStream0.equals((Object)sequenceInputStream1));
      assertFalse(sequenceInputStream1.equals((Object)sequenceInputStream0));
      assertNotSame(abstractReferenceMap_ReferenceStrength0, abstractReferenceMap_ReferenceStrength1);
      assertNotSame(abstractReferenceMap_ReferenceStrength1, abstractReferenceMap_ReferenceStrength0);
      assertNotSame(sequenceInputStream0, sequenceInputStream1);
      assertNotSame(sequenceInputStream1, sequenceInputStream0);
      
      // Undeclared exception!
      try { 
        abstractReferenceMap_ReferenceEntry0.next();
        fail("Expecting exception: ClassCastException");
      
      } catch(ClassCastException e) {
         //
         // org.apache.commons.collections4.map.AbstractHashedMap$HashEntry cannot be cast to org.apache.commons.collections4.map.AbstractReferenceMap$ReferenceEntry
         //
         verifyException("org.apache.commons.collections4.map.AbstractReferenceMap$ReferenceEntry", e);
      }
  }

  @Test(timeout = 4000)
  public void test04()  throws Throwable  {
      ReferenceIdentityMap<Object, Object> referenceIdentityMap0 = new ReferenceIdentityMap<Object, Object>();
      assertNotNull(referenceIdentityMap0);
      
      referenceIdentityMap0.purge();
      AbstractReferenceMap.ReferenceKeySetIterator<Object> abstractReferenceMap_ReferenceKeySetIterator0 = new AbstractReferenceMap.ReferenceKeySetIterator<Object>(referenceIdentityMap0);
      assertNotNull(abstractReferenceMap_ReferenceKeySetIterator0);
      
      ReferenceIdentityMap<Object, SoftReference<InputStream>> referenceIdentityMap1 = new ReferenceIdentityMap<Object, SoftReference<InputStream>>();
      assertNotNull(referenceIdentityMap1);
      
      referenceIdentityMap1.purgeBeforeRead();
      ReferenceMap<AbstractMap.SimpleImmutableEntry<Integer, String>, InputStream> referenceMap0 = new ReferenceMap<AbstractMap.SimpleImmutableEntry<Integer, String>, InputStream>();
      assertNotNull(referenceMap0);
      
      AbstractReferenceMap.ReferenceEntrySetIterator<AbstractMap.SimpleImmutableEntry<Integer, String>, InputStream> abstractReferenceMap_ReferenceEntrySetIterator0 = new AbstractReferenceMap.ReferenceEntrySetIterator<AbstractMap.SimpleImmutableEntry<Integer, String>, InputStream>(referenceMap0);
      assertNotNull(abstractReferenceMap_ReferenceEntrySetIterator0);
      
      // Undeclared exception!
      try { 
        abstractReferenceMap_ReferenceEntrySetIterator0.nextEntry();
        fail("Expecting exception: NoSuchElementException");
      
      } catch(NoSuchElementException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.apache.commons.collections4.map.AbstractReferenceMap$ReferenceBaseIterator", e);
      }
  }

  @Test(timeout = 4000)
  public void test05()  throws Throwable  {
      AbstractReferenceMap.ReferenceStrength abstractReferenceMap_ReferenceStrength0 = AbstractReferenceMap.ReferenceStrength.SOFT;
      ReferenceMap<InputStream, SequenceInputStream> referenceMap0 = new ReferenceMap<InputStream, SequenceInputStream>(abstractReferenceMap_ReferenceStrength0, abstractReferenceMap_ReferenceStrength0, 163, 163, true);
      assertNotNull(referenceMap0);
      
      Iterator<Map.Entry<InputStream, SequenceInputStream>> iterator0 = (Iterator<Map.Entry<InputStream, SequenceInputStream>>)referenceMap0.createEntrySetIterator();
      assertNotNull(iterator0);
      
      Iterator<InputStream> iterator1 = referenceMap0.createKeySetIterator();
      assertNotNull(iterator1);
      
      AbstractReferenceMap.ReferenceKeySetIterator<InputStream> abstractReferenceMap_ReferenceKeySetIterator0 = new AbstractReferenceMap.ReferenceKeySetIterator<InputStream>(referenceMap0);
      assertNotNull(abstractReferenceMap_ReferenceKeySetIterator0);
      
      AbstractReferenceMap.ReferenceStrength abstractReferenceMap_ReferenceStrength1 = AbstractReferenceMap.ReferenceStrength.SOFT;
      AbstractReferenceMap.ReferenceStrength abstractReferenceMap_ReferenceStrength2 = AbstractReferenceMap.ReferenceStrength.SOFT;
      ReferenceIdentityMap<SequenceInputStream, PhantomReference<String>> referenceIdentityMap0 = new ReferenceIdentityMap<SequenceInputStream, PhantomReference<String>>(abstractReferenceMap_ReferenceStrength1, abstractReferenceMap_ReferenceStrength2, true);
      assertNotNull(referenceIdentityMap0);
      
      ReferenceMap<InputStream, Object> referenceMap1 = new ReferenceMap<InputStream, Object>();
      assertNotNull(referenceMap1);
      
      AbstractReferenceMap.ReferenceMapIterator<InputStream, Object> abstractReferenceMap_ReferenceMapIterator0 = new AbstractReferenceMap.ReferenceMapIterator<InputStream, Object>(referenceMap1);
      assertNotNull(abstractReferenceMap_ReferenceMapIterator0);
      
      // Undeclared exception!
      try { 
        abstractReferenceMap_ReferenceMapIterator0.getKey();
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // getKey() can only be called after next() and before remove()
         //
         verifyException("org.apache.commons.collections4.map.AbstractReferenceMap$ReferenceMapIterator", e);
      }
  }

  @Test(timeout = 4000)
  public void test06()  throws Throwable  {
      AbstractReferenceMap.ReferenceStrength abstractReferenceMap_ReferenceStrength0 = AbstractReferenceMap.ReferenceStrength.WEAK;
      AbstractReferenceMap.ReferenceStrength abstractReferenceMap_ReferenceStrength1 = AbstractReferenceMap.ReferenceStrength.HARD;
      int int0 = 1;
      ReferenceIdentityMap<AbstractMap.SimpleEntry<Integer, Object>, WeakReference<String>> referenceIdentityMap0 = new ReferenceIdentityMap<AbstractMap.SimpleEntry<Integer, Object>, WeakReference<String>>(abstractReferenceMap_ReferenceStrength0, abstractReferenceMap_ReferenceStrength1, 1, 1, true);
      assertFalse(abstractReferenceMap_ReferenceStrength0.equals((Object)abstractReferenceMap_ReferenceStrength1));
      assertFalse(abstractReferenceMap_ReferenceStrength1.equals((Object)abstractReferenceMap_ReferenceStrength0));
      assertNotNull(referenceIdentityMap0);
      
      AbstractReferenceMap.ReferenceStrength abstractReferenceMap_ReferenceStrength2 = AbstractReferenceMap.ReferenceStrength.SOFT;
      boolean boolean0 = referenceIdentityMap0.isKeyType(abstractReferenceMap_ReferenceStrength2);
      assertFalse(abstractReferenceMap_ReferenceStrength0.equals((Object)abstractReferenceMap_ReferenceStrength1));
      assertFalse(abstractReferenceMap_ReferenceStrength0.equals((Object)abstractReferenceMap_ReferenceStrength2));
      assertFalse(abstractReferenceMap_ReferenceStrength1.equals((Object)abstractReferenceMap_ReferenceStrength2));
      assertFalse(abstractReferenceMap_ReferenceStrength1.equals((Object)abstractReferenceMap_ReferenceStrength0));
      assertFalse(abstractReferenceMap_ReferenceStrength2.equals((Object)abstractReferenceMap_ReferenceStrength0));
      assertFalse(abstractReferenceMap_ReferenceStrength2.equals((Object)abstractReferenceMap_ReferenceStrength1));
      assertFalse(boolean0);
      assertNotSame(abstractReferenceMap_ReferenceStrength0, abstractReferenceMap_ReferenceStrength1);
      assertNotSame(abstractReferenceMap_ReferenceStrength0, abstractReferenceMap_ReferenceStrength2);
      assertNotSame(abstractReferenceMap_ReferenceStrength1, abstractReferenceMap_ReferenceStrength2);
      assertNotSame(abstractReferenceMap_ReferenceStrength1, abstractReferenceMap_ReferenceStrength0);
      assertNotSame(abstractReferenceMap_ReferenceStrength2, abstractReferenceMap_ReferenceStrength0);
      assertNotSame(abstractReferenceMap_ReferenceStrength2, abstractReferenceMap_ReferenceStrength1);
      
      AbstractReferenceMap.ReferenceStrength abstractReferenceMap_ReferenceStrength3 = AbstractReferenceMap.ReferenceStrength.WEAK;
      float float0 = 0.0F;
      ReferenceMap<Object, PhantomReference<String>> referenceMap0 = null;
      try {
        referenceMap0 = new ReferenceMap<Object, PhantomReference<String>>(abstractReferenceMap_ReferenceStrength0, abstractReferenceMap_ReferenceStrength3, 1, 0.0F);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Load factor must be greater than 0
         //
         verifyException("org.apache.commons.collections4.map.AbstractHashedMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test07()  throws Throwable  {
      ReferenceIdentityMap<PhantomReference<String>, Integer> referenceIdentityMap0 = new ReferenceIdentityMap<PhantomReference<String>, Integer>();
      assertNotNull(referenceIdentityMap0);
      
      ReferenceQueue<String> referenceQueue0 = new ReferenceQueue<String>();
      assertNotNull(referenceQueue0);
      
      PhantomReference<String> phantomReference0 = new PhantomReference<String>("", referenceQueue0);
      assertNotNull(phantomReference0);
      assertFalse(phantomReference0.isEnqueued());
      
      Integer integer0 = new Integer((-66));
      assertNotNull(integer0);
      assertEquals((-66), (int)integer0);
      
      Integer integer1 = referenceIdentityMap0.put(phantomReference0, integer0);
      assertNull(integer1);
      assertFalse(phantomReference0.isEnqueued());
      
      Integer integer2 = referenceIdentityMap0.put(phantomReference0, integer0);
      assertNotNull(integer2);
      assertEquals((-66), (int)integer2);
      assertFalse(phantomReference0.isEnqueued());
      
      ReferenceQueue<Object> referenceQueue1 = new ReferenceQueue<Object>();
      assertNotNull(referenceQueue1);
      
      Reference<?> reference0 = referenceQueue1.poll();
      assertNull(reference0);
      
      PhantomReference<String> phantomReference1 = new PhantomReference<String>("6~Pd';y@?R", referenceQueue1);
      assertFalse(phantomReference1.equals((Object)phantomReference0));
      assertNotNull(phantomReference1);
      assertFalse(phantomReference1.isEnqueued());
      
      phantomReference1.clear();
      assertFalse(phantomReference1.equals((Object)phantomReference0));
      assertNotSame(phantomReference1, phantomReference0);
      assertFalse(phantomReference1.isEnqueued());
      
      Integer integer3 = new Integer(61);
      assertFalse(integer3.equals((Object)integer0));
      assertFalse(integer3.equals((Object)integer2));
      assertNotNull(integer3);
      assertEquals(61, (int)integer3);
      
      Integer integer4 = referenceIdentityMap0.put(phantomReference1, integer3);
      assertFalse(phantomReference1.equals((Object)phantomReference0));
      assertFalse(integer3.equals((Object)integer0));
      assertFalse(integer3.equals((Object)integer2));
      assertNull(integer4);
      assertNotSame(phantomReference1, phantomReference0);
      assertFalse(phantomReference1.isEnqueued());
      
      int int0 = referenceIdentityMap0.size();
      assertEquals(2, int0);
      
      ReferenceIdentityMap<InputStream, String> referenceIdentityMap1 = new ReferenceIdentityMap<InputStream, String>();
      assertNotNull(referenceIdentityMap1);
      
      AbstractReferenceMap.ReferenceBaseIterator<InputStream, String> abstractReferenceMap_ReferenceBaseIterator0 = new AbstractReferenceMap.ReferenceBaseIterator<InputStream, String>(referenceIdentityMap1);
      assertNotNull(abstractReferenceMap_ReferenceBaseIterator0);
      
      // Undeclared exception!
      try { 
        abstractReferenceMap_ReferenceBaseIterator0.remove();
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.apache.commons.collections4.map.AbstractReferenceMap$ReferenceBaseIterator", e);
      }
  }

  @Test(timeout = 4000)
  public void test08()  throws Throwable  {
      ReferenceIdentityMap<Integer, AbstractReferenceMap.ReferenceEntry<SequenceInputStream, Integer>> referenceIdentityMap0 = new ReferenceIdentityMap<Integer, AbstractReferenceMap.ReferenceEntry<SequenceInputStream, Integer>>();
      assertNotNull(referenceIdentityMap0);
      
      AbstractReferenceMap.ReferenceEntrySetIterator<Integer, AbstractReferenceMap.ReferenceEntry<SequenceInputStream, Integer>> abstractReferenceMap_ReferenceEntrySetIterator0 = new AbstractReferenceMap.ReferenceEntrySetIterator<Integer, AbstractReferenceMap.ReferenceEntry<SequenceInputStream, Integer>>(referenceIdentityMap0);
      assertNotNull(abstractReferenceMap_ReferenceEntrySetIterator0);
      
      int int0 = (-1430);
      Integer integer0 = new Integer((-1430));
      assertTrue(integer0.equals((Object)int0));
      assertNotNull(integer0);
      assertEquals((-1430), (int)integer0);
      
      abstractReferenceMap_ReferenceEntrySetIterator0.currentKey = integer0;
      AbstractReferenceMap.ReferenceEntry<Integer, AbstractReferenceMap.ReferenceEntry<SequenceInputStream, Integer>> abstractReferenceMap_ReferenceEntry0 = abstractReferenceMap_ReferenceEntrySetIterator0.currentEntry();
      assertNull(abstractReferenceMap_ReferenceEntry0);
      
      boolean boolean0 = abstractReferenceMap_ReferenceEntrySetIterator0.hasNext();
      assertFalse(boolean0);
      
      // Undeclared exception!
      try { 
        abstractReferenceMap_ReferenceEntrySetIterator0.next();
        fail("Expecting exception: NoSuchElementException");
      
      } catch(NoSuchElementException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.apache.commons.collections4.map.AbstractReferenceMap$ReferenceBaseIterator", e);
      }
  }

  @Test(timeout = 4000)
  public void test09()  throws Throwable  {
      AbstractReferenceMap.ReferenceStrength abstractReferenceMap_ReferenceStrength0 = AbstractReferenceMap.ReferenceStrength.HARD;
      AbstractReferenceMap.ReferenceStrength abstractReferenceMap_ReferenceStrength1 = AbstractReferenceMap.ReferenceStrength.HARD;
      ReferenceMap<Integer, AbstractMap.SimpleEntry<SequenceInputStream, Object>> referenceMap0 = new ReferenceMap<Integer, AbstractMap.SimpleEntry<SequenceInputStream, Object>>(abstractReferenceMap_ReferenceStrength0, abstractReferenceMap_ReferenceStrength1, true);
      assertNotNull(referenceMap0);
      
      SoftReference<Object> softReference0 = new SoftReference<Object>(abstractReferenceMap_ReferenceStrength0);
      assertNotNull(softReference0);
      assertFalse(softReference0.isEnqueued());
      
      softReference0.clear();
      assertSame(abstractReferenceMap_ReferenceStrength0, abstractReferenceMap_ReferenceStrength1);
      assertFalse(softReference0.isEnqueued());
      
      referenceMap0.purge(softReference0);
      assertSame(abstractReferenceMap_ReferenceStrength0, abstractReferenceMap_ReferenceStrength1);
      assertSame(abstractReferenceMap_ReferenceStrength1, abstractReferenceMap_ReferenceStrength0);
      assertFalse(softReference0.isEnqueued());
      
      AbstractReferenceMap.ReferenceStrength abstractReferenceMap_ReferenceStrength2 = AbstractReferenceMap.ReferenceStrength.HARD;
      ReferenceMap<PhantomReference<String>, InputStream> referenceMap1 = new ReferenceMap<PhantomReference<String>, InputStream>(abstractReferenceMap_ReferenceStrength2, abstractReferenceMap_ReferenceStrength2, false);
      assertNotNull(referenceMap1);
      
      // Undeclared exception!
      try { 
        referenceMap1.clone();
        fail("Expecting exception: InternalError");
      
      } catch(InternalError e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.apache.commons.collections4.map.AbstractHashedMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test10()  throws Throwable  {
      AbstractReferenceMap.ReferenceStrength abstractReferenceMap_ReferenceStrength0 = AbstractReferenceMap.ReferenceStrength.HARD;
      ReferenceMap<Integer, SoftReference<String>> referenceMap0 = new ReferenceMap<Integer, SoftReference<String>>(abstractReferenceMap_ReferenceStrength0, abstractReferenceMap_ReferenceStrength0, 2, 988.9885F);
      assertNotNull(referenceMap0);
      
      Enumeration<InputStream> enumeration0 = (Enumeration<InputStream>) mock(Enumeration.class, new ViolatedAssumptionAnswer());
      doReturn(false).when(enumeration0).hasMoreElements();
      SequenceInputStream sequenceInputStream0 = new SequenceInputStream(enumeration0);
      assertNotNull(sequenceInputStream0);
      
      AbstractHashedMap.HashEntry<Integer, SoftReference<String>> abstractHashedMap_HashEntry0 = referenceMap0.getEntry(sequenceInputStream0);
      assertNull(abstractHashedMap_HashEntry0);
      
      AbstractReferenceMap.ReferenceStrength abstractReferenceMap_ReferenceStrength1 = AbstractReferenceMap.ReferenceStrength.SOFT;
      AbstractReferenceMap.ReferenceStrength abstractReferenceMap_ReferenceStrength2 = AbstractReferenceMap.ReferenceStrength.HARD;
      byte[] byteArray0 = new byte[6];
      byteArray0[0] = (byte) (-48);
      byteArray0[1] = (byte)94;
      byteArray0[2] = (byte)50;
      byteArray0[3] = (byte)44;
      byteArray0[4] = (byte)70;
      byteArray0[5] = (byte)9;
      int int0 = sequenceInputStream0.read(byteArray0, 0, (-1114));
      assertEquals(6, byteArray0.length);
      assertArrayEquals(new byte[] {(byte) (-48), (byte)94, (byte)50, (byte)44, (byte)70, (byte)9}, byteArray0);
      assertEquals((-1), int0);
      
      Integer integer0 = new Integer((byte)44);
      assertFalse(integer0.equals((Object)int0));
      assertNotNull(integer0);
      assertEquals(44, (int)integer0);
      
      ReferenceQueue<Object> referenceQueue0 = new ReferenceQueue<Object>();
      assertNotNull(referenceQueue0);
      
      AbstractReferenceMap.SoftRef<String> abstractReferenceMap_SoftRef0 = new AbstractReferenceMap.SoftRef<String>((-1114), "", referenceQueue0);
      assertNotNull(abstractReferenceMap_SoftRef0);
      assertFalse(abstractReferenceMap_SoftRef0.isEnqueued());
      
      abstractReferenceMap_SoftRef0.clear();
      assertFalse(abstractReferenceMap_SoftRef0.isEnqueued());
      
      SoftReference<String> softReference0 = referenceMap0.put(integer0, abstractReferenceMap_SoftRef0);
      assertFalse(abstractReferenceMap_ReferenceStrength0.equals((Object)abstractReferenceMap_ReferenceStrength1));
      assertFalse(integer0.equals((Object)int0));
      assertNull(softReference0);
      assertSame(abstractReferenceMap_ReferenceStrength0, abstractReferenceMap_ReferenceStrength2);
      assertNotSame(abstractReferenceMap_ReferenceStrength0, abstractReferenceMap_ReferenceStrength1);
      assertFalse(abstractReferenceMap_SoftRef0.isEnqueued());
      
      ReferenceIdentityMap<String, Object> referenceIdentityMap0 = new ReferenceIdentityMap<String, Object>(abstractReferenceMap_ReferenceStrength1, abstractReferenceMap_ReferenceStrength2);
      assertFalse(abstractReferenceMap_ReferenceStrength1.equals((Object)abstractReferenceMap_ReferenceStrength2));
      assertFalse(abstractReferenceMap_ReferenceStrength1.equals((Object)abstractReferenceMap_ReferenceStrength0));
      assertFalse(abstractReferenceMap_ReferenceStrength2.equals((Object)abstractReferenceMap_ReferenceStrength1));
      assertNotNull(referenceIdentityMap0);
      
      boolean boolean0 = referenceIdentityMap0.isEmpty();
      assertFalse(abstractReferenceMap_ReferenceStrength1.equals((Object)abstractReferenceMap_ReferenceStrength2));
      assertFalse(abstractReferenceMap_ReferenceStrength1.equals((Object)abstractReferenceMap_ReferenceStrength0));
      assertFalse(abstractReferenceMap_ReferenceStrength2.equals((Object)abstractReferenceMap_ReferenceStrength1));
      assertTrue(boolean0);
      assertNotSame(abstractReferenceMap_ReferenceStrength1, abstractReferenceMap_ReferenceStrength2);
      assertNotSame(abstractReferenceMap_ReferenceStrength1, abstractReferenceMap_ReferenceStrength0);
      assertNotSame(abstractReferenceMap_ReferenceStrength2, abstractReferenceMap_ReferenceStrength1);
      assertSame(abstractReferenceMap_ReferenceStrength2, abstractReferenceMap_ReferenceStrength0);
      
      // Undeclared exception!
      try { 
        referenceIdentityMap0.isEqualKey(referenceMap0, sequenceInputStream0);
        fail("Expecting exception: ClassCastException");
      
      } catch(ClassCastException e) {
         //
         // java.io.SequenceInputStream cannot be cast to java.lang.ref.Reference
         //
         verifyException("org.apache.commons.collections4.map.ReferenceIdentityMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test11()  throws Throwable  {
      AbstractReferenceMap.ReferenceStrength abstractReferenceMap_ReferenceStrength0 = AbstractReferenceMap.ReferenceStrength.SOFT;
      ReferenceIdentityMap<Integer, Integer> referenceIdentityMap0 = new ReferenceIdentityMap<Integer, Integer>(abstractReferenceMap_ReferenceStrength0, abstractReferenceMap_ReferenceStrength0, true);
      assertNotNull(referenceIdentityMap0);
      
      Object object0 = new Object();
      assertNotNull(object0);
      
      // Undeclared exception!
      try { 
        referenceIdentityMap0.isEqualKey(abstractReferenceMap_ReferenceStrength0, object0);
        fail("Expecting exception: ClassCastException");
      
      } catch(ClassCastException e) {
         //
         // java.lang.Object cannot be cast to java.lang.ref.Reference
         //
         verifyException("org.apache.commons.collections4.map.ReferenceIdentityMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test12()  throws Throwable  {
      AbstractReferenceMap.ReferenceStrength abstractReferenceMap_ReferenceStrength0 = AbstractReferenceMap.ReferenceStrength.SOFT;
      AbstractReferenceMap.ReferenceStrength abstractReferenceMap_ReferenceStrength1 = AbstractReferenceMap.ReferenceStrength.HARD;
      boolean boolean0 = true;
      ReferenceIdentityMap<WeakReference<Object>, Object> referenceIdentityMap0 = new ReferenceIdentityMap<WeakReference<Object>, Object>(abstractReferenceMap_ReferenceStrength0, abstractReferenceMap_ReferenceStrength1, true);
      assertFalse(abstractReferenceMap_ReferenceStrength0.equals((Object)abstractReferenceMap_ReferenceStrength1));
      assertFalse(abstractReferenceMap_ReferenceStrength1.equals((Object)abstractReferenceMap_ReferenceStrength0));
      assertNotNull(referenceIdentityMap0);
      
      AbstractReferenceMap.ReferenceStrength abstractReferenceMap_ReferenceStrength2 = AbstractReferenceMap.ReferenceStrength.HARD;
      int int0 = 1076;
      float float0 = 3055.1472F;
      ReferenceIdentityMap<InputStream, String> referenceIdentityMap1 = new ReferenceIdentityMap<InputStream, String>(abstractReferenceMap_ReferenceStrength2, abstractReferenceMap_ReferenceStrength2, 1076, 3055.1472F);
      assertFalse(abstractReferenceMap_ReferenceStrength2.equals((Object)abstractReferenceMap_ReferenceStrength0));
      assertNotNull(referenceIdentityMap1);
      
      ReferenceIdentityMap<Object, SequenceInputStream> referenceIdentityMap2 = new ReferenceIdentityMap<Object, SequenceInputStream>(abstractReferenceMap_ReferenceStrength0, abstractReferenceMap_ReferenceStrength2, true);
      assertFalse(abstractReferenceMap_ReferenceStrength0.equals((Object)abstractReferenceMap_ReferenceStrength1));
      assertFalse(abstractReferenceMap_ReferenceStrength0.equals((Object)abstractReferenceMap_ReferenceStrength2));
      assertFalse(abstractReferenceMap_ReferenceStrength2.equals((Object)abstractReferenceMap_ReferenceStrength0));
      assertNotNull(referenceIdentityMap2);
      
      PushbackInputStream pushbackInputStream0 = new PushbackInputStream((InputStream) null);
      assertNotNull(pushbackInputStream0);
      
      String string0 = referenceIdentityMap1.put(pushbackInputStream0, " &b");
      assertFalse(abstractReferenceMap_ReferenceStrength2.equals((Object)abstractReferenceMap_ReferenceStrength0));
      assertNull(string0);
      assertSame(abstractReferenceMap_ReferenceStrength2, abstractReferenceMap_ReferenceStrength1);
      assertNotSame(abstractReferenceMap_ReferenceStrength2, abstractReferenceMap_ReferenceStrength0);
      
      AbstractReferenceMap.ReferenceValuesIterator<SequenceInputStream> abstractReferenceMap_ReferenceValuesIterator0 = new AbstractReferenceMap.ReferenceValuesIterator<SequenceInputStream>(referenceIdentityMap2);
      assertFalse(abstractReferenceMap_ReferenceStrength0.equals((Object)abstractReferenceMap_ReferenceStrength1));
      assertFalse(abstractReferenceMap_ReferenceStrength0.equals((Object)abstractReferenceMap_ReferenceStrength2));
      assertFalse(abstractReferenceMap_ReferenceStrength2.equals((Object)abstractReferenceMap_ReferenceStrength0));
      assertNotNull(abstractReferenceMap_ReferenceValuesIterator0);
      
      abstractReferenceMap_ReferenceValuesIterator0.nextKey = (Object) referenceIdentityMap0;
      boolean boolean1 = referenceIdentityMap2.containsKey(referenceIdentityMap1);
      assertFalse(abstractReferenceMap_ReferenceStrength0.equals((Object)abstractReferenceMap_ReferenceStrength1));
      assertFalse(abstractReferenceMap_ReferenceStrength0.equals((Object)abstractReferenceMap_ReferenceStrength2));
      assertFalse(abstractReferenceMap_ReferenceStrength2.equals((Object)abstractReferenceMap_ReferenceStrength0));
      assertFalse(boolean1 == boolean0);
      assertFalse(boolean1);
      assertNotSame(abstractReferenceMap_ReferenceStrength0, abstractReferenceMap_ReferenceStrength1);
      assertNotSame(abstractReferenceMap_ReferenceStrength0, abstractReferenceMap_ReferenceStrength2);
      assertSame(abstractReferenceMap_ReferenceStrength2, abstractReferenceMap_ReferenceStrength1);
      assertNotSame(abstractReferenceMap_ReferenceStrength2, abstractReferenceMap_ReferenceStrength0);
      
      abstractReferenceMap_ReferenceValuesIterator0.nextKey = (Object) referenceIdentityMap2;
      // Undeclared exception!
      try { 
        abstractReferenceMap_ReferenceValuesIterator0.next();
        fail("Expecting exception: NoSuchElementException");
      
      } catch(NoSuchElementException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.apache.commons.collections4.map.AbstractReferenceMap$ReferenceBaseIterator", e);
      }
  }

  @Test(timeout = 4000)
  public void test13()  throws Throwable  {
      int int0 = (-367);
      Integer integer0 = new Integer((-1));
      assertFalse(integer0.equals((Object)int0));
      assertNotNull(integer0);
      assertEquals((-1), (int)integer0);
      
      ReferenceQueue<Object> referenceQueue0 = new ReferenceQueue<Object>();
      assertNotNull(referenceQueue0);
      
      AbstractReferenceMap.SoftRef<Integer> abstractReferenceMap_SoftRef0 = new AbstractReferenceMap.SoftRef<Integer>((-367), integer0, referenceQueue0);
      assertFalse(integer0.equals((Object)int0));
      assertNotNull(abstractReferenceMap_SoftRef0);
      assertFalse(abstractReferenceMap_SoftRef0.isEnqueued());
      
      AbstractReferenceMap.WeakRef<SoftReference<Integer>> abstractReferenceMap_WeakRef0 = new AbstractReferenceMap.WeakRef<SoftReference<Integer>>((-1), abstractReferenceMap_SoftRef0, referenceQueue0);
      assertFalse(integer0.equals((Object)int0));
      assertNotNull(abstractReferenceMap_WeakRef0);
      assertFalse(abstractReferenceMap_SoftRef0.isEnqueued());
      assertFalse(abstractReferenceMap_WeakRef0.isEnqueued());
      
      ReferenceIdentityMap<InputStream, Object> referenceIdentityMap0 = new ReferenceIdentityMap<InputStream, Object>();
      assertNotNull(referenceIdentityMap0);
      
      AbstractReferenceMap.ReferenceKeySet<InputStream> abstractReferenceMap_ReferenceKeySet0 = new AbstractReferenceMap.ReferenceKeySet<InputStream>(referenceIdentityMap0);
      assertNotNull(abstractReferenceMap_ReferenceKeySet0);
      
      ReferenceMap<SequenceInputStream, Integer> referenceMap0 = new ReferenceMap<SequenceInputStream, Integer>();
      assertNotNull(referenceMap0);
      
      Integer integer1 = new Integer((-1));
      assertFalse(integer1.equals((Object)int0));
      assertTrue(integer1.equals((Object)integer0));
      assertNotNull(integer1);
      assertEquals((-1), (int)integer1);
      
      boolean boolean0 = referenceMap0.containsKey(integer1);
      assertFalse(integer1.equals((Object)int0));
      assertTrue(integer1.equals((Object)integer0));
      assertFalse(boolean0);
      
      AbstractReferenceMap.ReferenceStrength abstractReferenceMap_ReferenceStrength0 = AbstractReferenceMap.ReferenceStrength.HARD;
      AbstractReferenceMap.ReferenceStrength abstractReferenceMap_ReferenceStrength1 = AbstractReferenceMap.ReferenceStrength.WEAK;
      float float0 = 1.0F;
      ReferenceIdentityMap<PhantomReference<InputStream>, SequenceInputStream> referenceIdentityMap1 = null;
      try {
        referenceIdentityMap1 = new ReferenceIdentityMap<PhantomReference<InputStream>, SequenceInputStream>(abstractReferenceMap_ReferenceStrength0, abstractReferenceMap_ReferenceStrength1, (-466), 1.0F);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Initial capacity must be a non negative number
         //
         verifyException("org.apache.commons.collections4.map.AbstractHashedMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test14()  throws Throwable  {
      ReferenceMap<SoftReference<String>, Integer> referenceMap0 = new ReferenceMap<SoftReference<String>, Integer>();
      assertNotNull(referenceMap0);
      
      ReferenceIdentityMap<SequenceInputStream, SoftReference<Integer>> referenceIdentityMap0 = new ReferenceIdentityMap<SequenceInputStream, SoftReference<Integer>>();
      assertNotNull(referenceIdentityMap0);
      
      AbstractReferenceMap.ReferenceStrength abstractReferenceMap_ReferenceStrength0 = AbstractReferenceMap.ReferenceStrength.WEAK;
      AbstractReferenceMap.ReferenceStrength abstractReferenceMap_ReferenceStrength1 = AbstractReferenceMap.ReferenceStrength.WEAK;
      ReferenceMap<PhantomReference<Integer>, String> referenceMap1 = new ReferenceMap<PhantomReference<Integer>, String>(abstractReferenceMap_ReferenceStrength0, abstractReferenceMap_ReferenceStrength1, 3586, 1.0F, true);
      assertNotNull(referenceMap1);
      
      int int0 = 125;
      Integer integer0 = new Integer(125);
      assertTrue(integer0.equals((Object)int0));
      assertNotNull(integer0);
      assertEquals(125, (int)integer0);
      
      ReferenceQueue<Integer> referenceQueue0 = new ReferenceQueue<Integer>();
      assertNotNull(referenceQueue0);
      
      PhantomReference<Integer> phantomReference0 = new PhantomReference<Integer>(integer0, referenceQueue0);
      assertTrue(integer0.equals((Object)int0));
      assertNotNull(phantomReference0);
      assertFalse(phantomReference0.isEnqueued());
      
      String string0 = "g";
      String string1 = referenceMap1.put(phantomReference0, "g");
      assertTrue(integer0.equals((Object)int0));
      assertNull(string1);
      assertSame(abstractReferenceMap_ReferenceStrength0, abstractReferenceMap_ReferenceStrength1);
      assertSame(abstractReferenceMap_ReferenceStrength1, abstractReferenceMap_ReferenceStrength0);
      assertFalse(phantomReference0.isEnqueued());
      
      AbstractReferenceMap.ReferenceMapIterator<PhantomReference<Integer>, String> abstractReferenceMap_ReferenceMapIterator0 = new AbstractReferenceMap.ReferenceMapIterator<PhantomReference<Integer>, String>(referenceMap1);
      assertNotNull(abstractReferenceMap_ReferenceMapIterator0);
      
      // Undeclared exception!
      try { 
        abstractReferenceMap_ReferenceMapIterator0.getValue();
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // getValue() can only be called after next() and before remove()
         //
         verifyException("org.apache.commons.collections4.map.AbstractReferenceMap$ReferenceMapIterator", e);
      }
  }

  @Test(timeout = 4000)
  public void test15()  throws Throwable  {
      ReferenceMap<InputStream, Integer> referenceMap0 = new ReferenceMap<InputStream, Integer>();
      assertNotNull(referenceMap0);
      
      AbstractReferenceMap.ReferenceStrength abstractReferenceMap_ReferenceStrength0 = AbstractReferenceMap.ReferenceStrength.SOFT;
      int int0 = 2514;
      ReferenceIdentityMap<AbstractMap.SimpleImmutableEntry<InputStream, Object>, String> referenceIdentityMap0 = new ReferenceIdentityMap<AbstractMap.SimpleImmutableEntry<InputStream, Object>, String>(abstractReferenceMap_ReferenceStrength0, abstractReferenceMap_ReferenceStrength0, 2514, 2514);
      assertNotNull(referenceIdentityMap0);
      
      AbstractReferenceMap.ReferenceKeySetIterator<AbstractMap.SimpleImmutableEntry<InputStream, Object>> abstractReferenceMap_ReferenceKeySetIterator0 = new AbstractReferenceMap.ReferenceKeySetIterator<AbstractMap.SimpleImmutableEntry<InputStream, Object>>(referenceIdentityMap0);
      assertNotNull(abstractReferenceMap_ReferenceKeySetIterator0);
      
      AbstractReferenceMap.ReferenceEntry<AbstractMap.SimpleImmutableEntry<InputStream, Object>, Object> abstractReferenceMap_ReferenceEntry0 = abstractReferenceMap_ReferenceKeySetIterator0.currentEntry();
      assertNull(abstractReferenceMap_ReferenceEntry0);
      
      boolean boolean0 = abstractReferenceMap_ReferenceKeySetIterator0.hasNext();
      assertFalse(boolean0);
      
      // Undeclared exception!
      try { 
        abstractReferenceMap_ReferenceKeySetIterator0.next();
        fail("Expecting exception: NoSuchElementException");
      
      } catch(NoSuchElementException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.apache.commons.collections4.map.AbstractReferenceMap$ReferenceBaseIterator", e);
      }
  }

  @Test(timeout = 4000)
  public void test16()  throws Throwable  {
      AbstractReferenceMap.ReferenceStrength abstractReferenceMap_ReferenceStrength0 = AbstractReferenceMap.ReferenceStrength.SOFT;
      ReferenceMap<String, WeakReference<Object>> referenceMap0 = new ReferenceMap<String, WeakReference<Object>>(abstractReferenceMap_ReferenceStrength0, abstractReferenceMap_ReferenceStrength0);
      assertNotNull(referenceMap0);
      
      boolean boolean0 = referenceMap0.isEmpty();
      assertTrue(boolean0);
      
      AbstractReferenceMap.ReferenceStrength abstractReferenceMap_ReferenceStrength1 = AbstractReferenceMap.ReferenceStrength.HARD;
      ReferenceMap<InputStream, PhantomReference<Integer>> referenceMap1 = new ReferenceMap<InputStream, PhantomReference<Integer>>(abstractReferenceMap_ReferenceStrength1, abstractReferenceMap_ReferenceStrength0);
      assertFalse(abstractReferenceMap_ReferenceStrength0.equals((Object)abstractReferenceMap_ReferenceStrength1));
      assertFalse(abstractReferenceMap_ReferenceStrength1.equals((Object)abstractReferenceMap_ReferenceStrength0));
      assertNotNull(referenceMap1);
      
      MapIterator<InputStream, PhantomReference<Integer>> mapIterator0 = referenceMap1.mapIterator();
      assertFalse(abstractReferenceMap_ReferenceStrength0.equals((Object)abstractReferenceMap_ReferenceStrength1));
      assertFalse(abstractReferenceMap_ReferenceStrength1.equals((Object)abstractReferenceMap_ReferenceStrength0));
      assertNotNull(mapIterator0);
      assertNotSame(abstractReferenceMap_ReferenceStrength0, abstractReferenceMap_ReferenceStrength1);
      assertNotSame(abstractReferenceMap_ReferenceStrength1, abstractReferenceMap_ReferenceStrength0);
      assertFalse(mapIterator0.hasNext());
      
      AbstractReferenceMap.ReferenceStrength abstractReferenceMap_ReferenceStrength2 = AbstractReferenceMap.ReferenceStrength.SOFT;
      ReferenceIdentityMap<Integer, InputStream> referenceIdentityMap0 = new ReferenceIdentityMap<Integer, InputStream>(abstractReferenceMap_ReferenceStrength2, abstractReferenceMap_ReferenceStrength2, 1580, 1580, true);
      assertFalse(abstractReferenceMap_ReferenceStrength2.equals((Object)abstractReferenceMap_ReferenceStrength1));
      assertNotNull(referenceIdentityMap0);
      
      Iterator<InputStream> iterator0 = referenceIdentityMap0.createValuesIterator();
      assertFalse(abstractReferenceMap_ReferenceStrength2.equals((Object)abstractReferenceMap_ReferenceStrength1));
      assertNotNull(iterator0);
      assertNotSame(abstractReferenceMap_ReferenceStrength2, abstractReferenceMap_ReferenceStrength1);
      assertSame(abstractReferenceMap_ReferenceStrength2, abstractReferenceMap_ReferenceStrength0);
  }

  @Test(timeout = 4000)
  public void test17()  throws Throwable  {
      AbstractReferenceMap.ReferenceStrength abstractReferenceMap_ReferenceStrength0 = AbstractReferenceMap.ReferenceStrength.HARD;
      AbstractReferenceMap.ReferenceStrength abstractReferenceMap_ReferenceStrength1 = AbstractReferenceMap.ReferenceStrength.WEAK;
      ReferenceMap<SoftReference<Object>, PhantomReference<Integer>> referenceMap0 = new ReferenceMap<SoftReference<Object>, PhantomReference<Integer>>(abstractReferenceMap_ReferenceStrength0, abstractReferenceMap_ReferenceStrength1);
      assertFalse(abstractReferenceMap_ReferenceStrength0.equals((Object)abstractReferenceMap_ReferenceStrength1));
      assertFalse(abstractReferenceMap_ReferenceStrength1.equals((Object)abstractReferenceMap_ReferenceStrength0));
      assertNotNull(referenceMap0);
      
      referenceMap0.purge();
      assertFalse(abstractReferenceMap_ReferenceStrength0.equals((Object)abstractReferenceMap_ReferenceStrength1));
      assertFalse(abstractReferenceMap_ReferenceStrength1.equals((Object)abstractReferenceMap_ReferenceStrength0));
      assertNotSame(abstractReferenceMap_ReferenceStrength0, abstractReferenceMap_ReferenceStrength1);
      assertNotSame(abstractReferenceMap_ReferenceStrength1, abstractReferenceMap_ReferenceStrength0);
  }

  @Test(timeout = 4000)
  public void test18()  throws Throwable  {
      ReferenceIdentityMap<SequenceInputStream, Object> referenceIdentityMap0 = new ReferenceIdentityMap<SequenceInputStream, Object>();
      assertNotNull(referenceIdentityMap0);
      
      Set<Map.Entry<SequenceInputStream, Object>> set0 = (Set<Map.Entry<SequenceInputStream, Object>>)referenceIdentityMap0.entrySet();
      assertNotNull(set0);
      assertTrue(set0.isEmpty());
      assertEquals(0, set0.size());
      
      AbstractReferenceMap.ReferenceEntrySetIterator<SequenceInputStream, Object> abstractReferenceMap_ReferenceEntrySetIterator0 = new AbstractReferenceMap.ReferenceEntrySetIterator<SequenceInputStream, Object>(referenceIdentityMap0);
      assertNotNull(abstractReferenceMap_ReferenceEntrySetIterator0);
      
      AbstractReferenceMap.ReferenceEntry<SequenceInputStream, Object> abstractReferenceMap_ReferenceEntry0 = abstractReferenceMap_ReferenceEntrySetIterator0.currentEntry();
      assertNull(abstractReferenceMap_ReferenceEntry0);
      
      ReferenceIdentityMap<PhantomReference<String>, AbstractMap.SimpleEntry<Integer, Object>> referenceIdentityMap1 = new ReferenceIdentityMap<PhantomReference<String>, AbstractMap.SimpleEntry<Integer, Object>>();
      assertNotNull(referenceIdentityMap1);
      
      Set<Map.Entry<PhantomReference<String>, AbstractMap.SimpleEntry<Integer, Object>>> set1 = (Set<Map.Entry<PhantomReference<String>, AbstractMap.SimpleEntry<Integer, Object>>>)referenceIdentityMap1.entrySet();
      assertNotNull(set1);
      assertEquals(0, set1.size());
      assertTrue(set1.isEmpty());
      
      AbstractReferenceMap.ReferenceStrength abstractReferenceMap_ReferenceStrength0 = AbstractReferenceMap.ReferenceStrength.SOFT;
      int int0 = (-3499);
      ReferenceIdentityMap<InputStream, SequenceInputStream> referenceIdentityMap2 = null;
      try {
        referenceIdentityMap2 = new ReferenceIdentityMap<InputStream, SequenceInputStream>(abstractReferenceMap_ReferenceStrength0, abstractReferenceMap_ReferenceStrength0, (-3499), 2.40662F, true);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Initial capacity must be a non negative number
         //
         verifyException("org.apache.commons.collections4.map.AbstractHashedMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test19()  throws Throwable  {
      AbstractReferenceMap.ReferenceStrength abstractReferenceMap_ReferenceStrength0 = AbstractReferenceMap.ReferenceStrength.HARD;
      ReferenceIdentityMap<PhantomReference<Object>, Object> referenceIdentityMap0 = new ReferenceIdentityMap<PhantomReference<Object>, Object>(abstractReferenceMap_ReferenceStrength0, abstractReferenceMap_ReferenceStrength0, true);
      assertNotNull(referenceIdentityMap0);
      
      AbstractReferenceMap.ReferenceStrength abstractReferenceMap_ReferenceStrength1 = AbstractReferenceMap.ReferenceStrength.SOFT;
      ReferenceMap<PhantomReference<String>, Integer> referenceMap0 = new ReferenceMap<PhantomReference<String>, Integer>(abstractReferenceMap_ReferenceStrength0, abstractReferenceMap_ReferenceStrength1, false);
      assertFalse(abstractReferenceMap_ReferenceStrength0.equals((Object)abstractReferenceMap_ReferenceStrength1));
      assertFalse(abstractReferenceMap_ReferenceStrength1.equals((Object)abstractReferenceMap_ReferenceStrength0));
      assertNotNull(referenceMap0);
      
      ReferenceQueue<Object> referenceQueue0 = new ReferenceQueue<Object>();
      assertNotNull(referenceQueue0);
      
      PhantomReference<String> phantomReference0 = new PhantomReference<String>("'}6ehm8kXLhT<", referenceQueue0);
      assertNotNull(phantomReference0);
      assertFalse(phantomReference0.isEnqueued());
      
      Integer integer0 = new Integer(4085);
      assertNotNull(integer0);
      assertEquals(4085, (int)integer0);
      
      Integer integer1 = referenceMap0.put(phantomReference0, integer0);
      assertFalse(abstractReferenceMap_ReferenceStrength0.equals((Object)abstractReferenceMap_ReferenceStrength1));
      assertFalse(abstractReferenceMap_ReferenceStrength1.equals((Object)abstractReferenceMap_ReferenceStrength0));
      assertNull(integer1);
      assertNotSame(abstractReferenceMap_ReferenceStrength0, abstractReferenceMap_ReferenceStrength1);
      assertNotSame(abstractReferenceMap_ReferenceStrength1, abstractReferenceMap_ReferenceStrength0);
      assertFalse(phantomReference0.isEnqueued());
      
      boolean boolean0 = referenceMap0.isEqualKey(abstractReferenceMap_ReferenceStrength0, abstractReferenceMap_ReferenceStrength0);
      assertFalse(abstractReferenceMap_ReferenceStrength0.equals((Object)abstractReferenceMap_ReferenceStrength1));
      assertFalse(abstractReferenceMap_ReferenceStrength1.equals((Object)abstractReferenceMap_ReferenceStrength0));
      assertTrue(boolean0);
      assertNotSame(abstractReferenceMap_ReferenceStrength0, abstractReferenceMap_ReferenceStrength1);
      assertNotSame(abstractReferenceMap_ReferenceStrength1, abstractReferenceMap_ReferenceStrength0);
  }

  @Test(timeout = 4000)
  public void test20()  throws Throwable  {
      AbstractReferenceMap.ReferenceStrength abstractReferenceMap_ReferenceStrength0 = AbstractReferenceMap.ReferenceStrength.HARD;
      ReferenceIdentityMap<String, String> referenceIdentityMap0 = new ReferenceIdentityMap<String, String>(abstractReferenceMap_ReferenceStrength0, abstractReferenceMap_ReferenceStrength0, 0, 954.9F, false);
      assertNotNull(referenceIdentityMap0);
      
      AbstractReferenceMap.ReferenceMapIterator<String, String> abstractReferenceMap_ReferenceMapIterator0 = new AbstractReferenceMap.ReferenceMapIterator<String, String>(referenceIdentityMap0);
      assertNotNull(abstractReferenceMap_ReferenceMapIterator0);
      
      boolean boolean0 = abstractReferenceMap_ReferenceMapIterator0.hasNext();
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void test21()  throws Throwable  {
      AbstractHashedMap<WeakReference<Object>, String> abstractHashedMap0 = new AbstractHashedMap<WeakReference<Object>, String>();
      assertNotNull(abstractHashedMap0);
      assertTrue(abstractHashedMap0.isEmpty());
      
      AbstractReferenceMap.ReferenceKeySet<WeakReference<Object>> abstractReferenceMap_ReferenceKeySet0 = new AbstractReferenceMap.ReferenceKeySet<WeakReference<Object>>(abstractHashedMap0);
      assertNotNull(abstractReferenceMap_ReferenceKeySet0);
      assertTrue(abstractHashedMap0.isEmpty());
      
      Integer[] integerArray0 = new Integer[8];
      Integer integer0 = new Integer(1073741824);
      assertNotNull(integer0);
      assertEquals(1073741824, (int)integer0);
      
      integerArray0[0] = integer0;
      Integer integer1 = new Integer((int) integerArray0[0]);
      assertEquals(8, integerArray0.length);
      assertTrue(integer1.equals((Object)integer0));
      assertNotNull(integer1);
      assertEquals(1073741824, (int)integer1);
      
      integerArray0[1] = integer1;
      Integer integer2 = new Integer(1073741824);
      assertTrue(integer2.equals((Object)integer1));
      assertTrue(integer2.equals((Object)integer0));
      assertNotNull(integer2);
      assertEquals(1073741824, (int)integer2);
      
      integerArray0[2] = integer2;
      Integer integer3 = new Integer(4745);
      assertFalse(integer3.equals((Object)integer2));
      assertFalse(integer3.equals((Object)integer1));
      assertFalse(integer3.equals((Object)integer0));
      assertNotNull(integer3);
      assertEquals(4745, (int)integer3);
      
      integerArray0[3] = integer3;
      Integer integer4 = new Integer(1073741824);
      assertTrue(integer4.equals((Object)integer1));
      assertFalse(integer4.equals((Object)integer3));
      assertTrue(integer4.equals((Object)integer2));
      assertTrue(integer4.equals((Object)integer0));
      assertNotNull(integer4);
      assertEquals(1073741824, (int)integer4);
      
      integerArray0[4] = integer4;
      Integer integer5 = new Integer((int) integerArray0[1]);
      assertEquals(8, integerArray0.length);
      assertTrue(integer5.equals((Object)integer1));
      assertTrue(integer5.equals((Object)integer2));
      assertTrue(integer5.equals((Object)integer0));
      assertTrue(integer5.equals((Object)integer4));
      assertFalse(integer5.equals((Object)integer3));
      assertNotNull(integer5);
      assertEquals(1073741824, (int)integer5);
      
      integerArray0[5] = integer5;
      Integer integer6 = new Integer(0);
      assertFalse(integer6.equals((Object)integer2));
      assertFalse(integer6.equals((Object)integer4));
      assertFalse(integer6.equals((Object)integer1));
      assertFalse(integer6.equals((Object)integer0));
      assertFalse(integer6.equals((Object)integer3));
      assertFalse(integer6.equals((Object)integer5));
      assertNotNull(integer6);
      assertEquals(0, (int)integer6);
      
      integerArray0[6] = integer6;
      Integer integer7 = new Integer((int) integerArray0[3]);
      assertEquals(8, integerArray0.length);
      assertFalse(integer7.equals((Object)integer5));
      assertFalse(integer7.equals((Object)integer0));
      assertTrue(integer7.equals((Object)integer3));
      assertFalse(integer7.equals((Object)integer2));
      assertFalse(integer7.equals((Object)integer4));
      assertFalse(integer7.equals((Object)integer6));
      assertFalse(integer7.equals((Object)integer1));
      assertNotNull(integer7);
      assertEquals(4745, (int)integer7);
      
      integerArray0[7] = integer7;
      Integer[] integerArray1 = abstractReferenceMap_ReferenceKeySet0.toArray(integerArray0);
      assertEquals(8, integerArray0.length);
      assertEquals(8, integerArray1.length);
      assertNotNull(integerArray1);
      assertSame(integerArray0, integerArray1);
      assertSame(integerArray1, integerArray0);
      assertTrue(abstractHashedMap0.isEmpty());
  }

  @Test(timeout = 4000)
  public void test22()  throws Throwable  {
      AbstractHashedMap<SoftReference<Integer>, Integer> abstractHashedMap0 = new AbstractHashedMap<SoftReference<Integer>, Integer>();
      assertNotNull(abstractHashedMap0);
      assertTrue(abstractHashedMap0.isEmpty());
      
      AbstractReferenceMap.ReferenceKeySet<SoftReference<Integer>> abstractReferenceMap_ReferenceKeySet0 = new AbstractReferenceMap.ReferenceKeySet<SoftReference<Integer>>(abstractHashedMap0);
      assertNotNull(abstractReferenceMap_ReferenceKeySet0);
      assertTrue(abstractHashedMap0.isEmpty());
      
      Object[] objectArray0 = abstractReferenceMap_ReferenceKeySet0.toArray();
      assertEquals(0, objectArray0.length);
      assertNotNull(objectArray0);
      assertTrue(abstractHashedMap0.isEmpty());
  }

  @Test(timeout = 4000)
  public void test23()  throws Throwable  {
      AbstractReferenceMap.ReferenceStrength abstractReferenceMap_ReferenceStrength0 = AbstractReferenceMap.ReferenceStrength.HARD;
      ReferenceMap<Object, AbstractMap.SimpleEntry<Object, Object>> referenceMap0 = new ReferenceMap<Object, AbstractMap.SimpleEntry<Object, Object>>(abstractReferenceMap_ReferenceStrength0, abstractReferenceMap_ReferenceStrength0, true);
      assertNotNull(referenceMap0);
      
      MapIterator<Object, AbstractMap.SimpleEntry<Object, Object>> mapIterator0 = referenceMap0.mapIterator();
      assertNotNull(mapIterator0);
      assertFalse(mapIterator0.hasNext());
      
      ReferenceMap<Object, SoftReference<Object>> referenceMap1 = new ReferenceMap<Object, SoftReference<Object>>(abstractReferenceMap_ReferenceStrength0, abstractReferenceMap_ReferenceStrength0, true);
      assertNotNull(referenceMap1);
      
      ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
      assertNotNull(byteArrayOutputStream0);
      assertEquals("", byteArrayOutputStream0.toString());
      assertEquals(0, byteArrayOutputStream0.size());
      
      MockPrintStream mockPrintStream0 = new MockPrintStream(byteArrayOutputStream0, false);
      assertNotNull(mockPrintStream0);
      
      PrintStream printStream0 = mockPrintStream0.append(':');
      assertNotNull(printStream0);
      assertSame(mockPrintStream0, printStream0);
      assertSame(printStream0, mockPrintStream0);
      assertEquals(":", byteArrayOutputStream0.toString());
      assertEquals(1, byteArrayOutputStream0.size());
      
      ObjectOutputStream objectOutputStream0 = new ObjectOutputStream(printStream0);
      assertNotNull(objectOutputStream0);
      assertEquals(":\uE108\u0000\u0005", byteArrayOutputStream0.toString());
      assertEquals(5, byteArrayOutputStream0.size());
      
      referenceMap1.doWriteObject(objectOutputStream0);
      assertSame(mockPrintStream0, printStream0);
      assertSame(printStream0, mockPrintStream0);
      assertEquals(25, byteArrayOutputStream0.size());
      assertEquals(":\uE108\u0000\u0005w\u0011\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001?@\u0000\u0000\u0000\u0000\u0000\u0010p", byteArrayOutputStream0.toString());
      
      AbstractReferenceMap.ReferenceStrength abstractReferenceMap_ReferenceStrength1 = AbstractReferenceMap.ReferenceStrength.WEAK;
      ReferenceIdentityMap<SoftReference<String>, Object> referenceIdentityMap0 = new ReferenceIdentityMap<SoftReference<String>, Object>(abstractReferenceMap_ReferenceStrength1, abstractReferenceMap_ReferenceStrength1, true);
      assertFalse(abstractReferenceMap_ReferenceStrength1.equals((Object)abstractReferenceMap_ReferenceStrength0));
      assertNotNull(referenceIdentityMap0);
      
      int int0 = referenceIdentityMap0.size();
      assertFalse(abstractReferenceMap_ReferenceStrength1.equals((Object)abstractReferenceMap_ReferenceStrength0));
      assertEquals(0, int0);
      assertNotSame(abstractReferenceMap_ReferenceStrength1, abstractReferenceMap_ReferenceStrength0);
      
      Set<SoftReference<String>> set0 = referenceIdentityMap0.keySet();
      assertFalse(abstractReferenceMap_ReferenceStrength1.equals((Object)abstractReferenceMap_ReferenceStrength0));
      assertNotNull(set0);
      assertNotSame(abstractReferenceMap_ReferenceStrength1, abstractReferenceMap_ReferenceStrength0);
      assertEquals(0, set0.size());
      assertTrue(set0.isEmpty());
      
      MapIterator<SoftReference<String>, Object> mapIterator1 = referenceIdentityMap0.mapIterator();
      assertFalse(abstractReferenceMap_ReferenceStrength1.equals((Object)abstractReferenceMap_ReferenceStrength0));
      assertNotNull(mapIterator1);
      assertNotSame(abstractReferenceMap_ReferenceStrength1, abstractReferenceMap_ReferenceStrength0);
      assertFalse(mapIterator1.hasNext());
      
      AbstractReferenceMap.ReferenceStrength abstractReferenceMap_ReferenceStrength2 = AbstractReferenceMap.ReferenceStrength.WEAK;
      ReferenceIdentityMap<AbstractReferenceMap.ReferenceEntry<Object, String>, Object> referenceIdentityMap1 = new ReferenceIdentityMap<AbstractReferenceMap.ReferenceEntry<Object, String>, Object>(abstractReferenceMap_ReferenceStrength2, abstractReferenceMap_ReferenceStrength1, true);
      assertFalse(abstractReferenceMap_ReferenceStrength1.equals((Object)abstractReferenceMap_ReferenceStrength0));
      assertFalse(abstractReferenceMap_ReferenceStrength2.equals((Object)abstractReferenceMap_ReferenceStrength0));
      assertNotNull(referenceIdentityMap1);
      
      AbstractReferenceMap.ReferenceEntrySet<AbstractReferenceMap.ReferenceEntry<Object, String>, Object> abstractReferenceMap_ReferenceEntrySet0 = new AbstractReferenceMap.ReferenceEntrySet<AbstractReferenceMap.ReferenceEntry<Object, String>, Object>(referenceIdentityMap1);
      assertFalse(abstractReferenceMap_ReferenceStrength1.equals((Object)abstractReferenceMap_ReferenceStrength0));
      assertFalse(abstractReferenceMap_ReferenceStrength2.equals((Object)abstractReferenceMap_ReferenceStrength0));
      assertNotNull(abstractReferenceMap_ReferenceEntrySet0);
      
      WeakReference<String>[] weakReferenceArray0 = (WeakReference<String>[]) Array.newInstance(WeakReference.class, 6);
      ReferenceQueue<String> referenceQueue0 = new ReferenceQueue<String>();
      assertNotNull(referenceQueue0);
      
      AbstractReferenceMap.WeakRef<String> abstractReferenceMap_WeakRef0 = new AbstractReferenceMap.WeakRef<String>((-1), "", referenceQueue0);
      assertNotNull(abstractReferenceMap_WeakRef0);
      assertFalse(abstractReferenceMap_WeakRef0.isEnqueued());
      
      weakReferenceArray0[0] = (WeakReference<String>) abstractReferenceMap_WeakRef0;
      WeakReference<String> weakReference0 = new WeakReference<String>("");
      assertNotNull(weakReference0);
      assertFalse(weakReference0.isEnqueued());
      
      weakReferenceArray0[1] = weakReference0;
      AbstractReferenceMap.WeakRef<String> abstractReferenceMap_WeakRef1 = new AbstractReferenceMap.WeakRef<String>(2, "", referenceQueue0);
      assertFalse(abstractReferenceMap_WeakRef1.equals((Object)abstractReferenceMap_WeakRef0));
      assertNotNull(abstractReferenceMap_WeakRef1);
      assertFalse(abstractReferenceMap_WeakRef1.isEnqueued());
      
      weakReferenceArray0[2] = (WeakReference<String>) abstractReferenceMap_WeakRef1;
      AbstractReferenceMap.WeakRef<String> abstractReferenceMap_WeakRef2 = new AbstractReferenceMap.WeakRef<String>((-1), "", referenceQueue0);
      assertFalse(abstractReferenceMap_WeakRef2.equals((Object)abstractReferenceMap_WeakRef1));
      assertFalse(abstractReferenceMap_WeakRef2.equals((Object)abstractReferenceMap_WeakRef0));
      assertNotNull(abstractReferenceMap_WeakRef2);
      assertFalse(abstractReferenceMap_WeakRef2.isEnqueued());
      
      weakReferenceArray0[3] = (WeakReference<String>) abstractReferenceMap_WeakRef2;
      WeakReference<String> weakReference1 = new WeakReference<String>("/y_].=%t");
      assertFalse(weakReference1.equals((Object)weakReference0));
      assertNotNull(weakReference1);
      assertFalse(weakReference1.isEnqueued());
      
      weakReferenceArray0[4] = weakReference1;
      ReferenceQueue<Object> referenceQueue1 = new ReferenceQueue<Object>();
      assertNotNull(referenceQueue1);
      
      WeakReference<String> weakReference2 = new WeakReference<String>("/y_].=%t", referenceQueue1);
      assertFalse(weakReference2.equals((Object)weakReference1));
      assertFalse(weakReference2.equals((Object)weakReference0));
      assertNotNull(weakReference2);
      assertFalse(weakReference2.isEnqueued());
      
      weakReferenceArray0[5] = weakReference2;
      WeakReference<String>[] weakReferenceArray1 = abstractReferenceMap_ReferenceEntrySet0.toArray(weakReferenceArray0);
      assertEquals(6, weakReferenceArray1.length);
      assertEquals(6, weakReferenceArray0.length);
      assertFalse(abstractReferenceMap_ReferenceStrength1.equals((Object)abstractReferenceMap_ReferenceStrength0));
      assertFalse(abstractReferenceMap_ReferenceStrength2.equals((Object)abstractReferenceMap_ReferenceStrength0));
      assertNotNull(weakReferenceArray1);
      assertSame(weakReferenceArray1, weakReferenceArray0);
      assertSame(weakReferenceArray0, weakReferenceArray1);
      assertSame(abstractReferenceMap_ReferenceStrength1, abstractReferenceMap_ReferenceStrength2);
      assertNotSame(abstractReferenceMap_ReferenceStrength1, abstractReferenceMap_ReferenceStrength0);
      assertNotSame(abstractReferenceMap_ReferenceStrength2, abstractReferenceMap_ReferenceStrength0);
      assertSame(abstractReferenceMap_ReferenceStrength2, abstractReferenceMap_ReferenceStrength1);
  }

  @Test(timeout = 4000)
  public void test24()  throws Throwable  {
      AbstractReferenceMap.ReferenceStrength abstractReferenceMap_ReferenceStrength0 = AbstractReferenceMap.ReferenceStrength.WEAK;
      ReferenceIdentityMap<AbstractReferenceMap.ReferenceEntry<Integer, SequenceInputStream>, WeakReference<Integer>> referenceIdentityMap0 = new ReferenceIdentityMap<AbstractReferenceMap.ReferenceEntry<Integer, SequenceInputStream>, WeakReference<Integer>>(abstractReferenceMap_ReferenceStrength0, abstractReferenceMap_ReferenceStrength0);
      assertNotNull(referenceIdentityMap0);
      
      int int0 = referenceIdentityMap0.hashEntry(abstractReferenceMap_ReferenceStrength0, abstractReferenceMap_ReferenceStrength0);
      assertEquals(0, int0);
      
      AbstractReferenceMap.ReferenceEntrySet<InputStream, AbstractReferenceMap.ReferenceEntry<String, String>> abstractReferenceMap_ReferenceEntrySet0 = new AbstractReferenceMap.ReferenceEntrySet<InputStream, AbstractReferenceMap.ReferenceEntry<String, String>>((AbstractHashedMap<InputStream, AbstractReferenceMap.ReferenceEntry<String, String>>) null);
      assertNotNull(abstractReferenceMap_ReferenceEntrySet0);
      
      Set<AbstractReferenceMap.ReferenceEntry<Integer, SequenceInputStream>> set0 = referenceIdentityMap0.keySet();
      assertNotNull(set0);
      assertEquals(0, set0.size());
      assertTrue(set0.isEmpty());
      
      String[] stringArray0 = new String[1];
      String string0 = "";
      stringArray0[0] = "";
      // Undeclared exception!
      try { 
        abstractReferenceMap_ReferenceEntrySet0.toArray(stringArray0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.apache.commons.collections4.map.AbstractHashedMap$EntrySet", e);
      }
  }

  @Test(timeout = 4000)
  public void test25()  throws Throwable  {
      AbstractReferenceMap.ReferenceStrength abstractReferenceMap_ReferenceStrength0 = AbstractReferenceMap.ReferenceStrength.WEAK;
      AbstractReferenceMap.ReferenceStrength abstractReferenceMap_ReferenceStrength1 = AbstractReferenceMap.ReferenceStrength.WEAK;
      boolean boolean0 = false;
      ReferenceMap<AbstractMap.SimpleEntry<Object, Object>, String> referenceMap0 = new ReferenceMap<AbstractMap.SimpleEntry<Object, Object>, String>(abstractReferenceMap_ReferenceStrength0, abstractReferenceMap_ReferenceStrength1, false);
      assertNotNull(referenceMap0);
      
      AbstractReferenceMap.ReferenceMapIterator<AbstractMap.SimpleEntry<Object, Object>, String> abstractReferenceMap_ReferenceMapIterator0 = new AbstractReferenceMap.ReferenceMapIterator<AbstractMap.SimpleEntry<Object, Object>, String>(referenceMap0);
      assertNotNull(abstractReferenceMap_ReferenceMapIterator0);
      
      // Undeclared exception!
      try { 
        abstractReferenceMap_ReferenceMapIterator0.setValue("");
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // setValue() can only be called after next() and before remove()
         //
         verifyException("org.apache.commons.collections4.map.AbstractReferenceMap$ReferenceMapIterator", e);
      }
  }

  @Test(timeout = 4000)
  public void test26()  throws Throwable  {
      AbstractReferenceMap.ReferenceStrength[] abstractReferenceMap_ReferenceStrengthArray0 = AbstractReferenceMap.ReferenceStrength.values();
      assertEquals(3, abstractReferenceMap_ReferenceStrengthArray0.length);
      assertNotNull(abstractReferenceMap_ReferenceStrengthArray0);
      
      ReferenceMap<InputStream, InputStream> referenceMap0 = new ReferenceMap<InputStream, InputStream>();
      assertNotNull(referenceMap0);
      
      PipedInputStream pipedInputStream0 = new PipedInputStream();
      assertNotNull(pipedInputStream0);
      assertEquals(0, pipedInputStream0.available());
      
      PipedOutputStream pipedOutputStream0 = new PipedOutputStream(pipedInputStream0);
      assertNotNull(pipedOutputStream0);
      assertEquals(0, pipedInputStream0.available());
      
      ObjectOutputStream objectOutputStream0 = new ObjectOutputStream(pipedOutputStream0);
      assertNotNull(objectOutputStream0);
      assertEquals(4, pipedInputStream0.available());
      
      referenceMap0.doWriteObject(objectOutputStream0);
      assertEquals(24, pipedInputStream0.available());
  }

  @Test(timeout = 4000)
  public void test27()  throws Throwable  {
      AbstractReferenceMap.ReferenceStrength abstractReferenceMap_ReferenceStrength0 = AbstractReferenceMap.ReferenceStrength.WEAK;
      AbstractReferenceMap.ReferenceStrength abstractReferenceMap_ReferenceStrength1 = AbstractReferenceMap.ReferenceStrength.SOFT;
      ReferenceMap<AbstractReferenceMap.ReferenceEntry<SequenceInputStream, Object>, InputStream> referenceMap0 = new ReferenceMap<AbstractReferenceMap.ReferenceEntry<SequenceInputStream, Object>, InputStream>(abstractReferenceMap_ReferenceStrength0, abstractReferenceMap_ReferenceStrength1, 0, 2465.6262F);
      assertFalse(abstractReferenceMap_ReferenceStrength0.equals((Object)abstractReferenceMap_ReferenceStrength1));
      assertFalse(abstractReferenceMap_ReferenceStrength1.equals((Object)abstractReferenceMap_ReferenceStrength0));
      assertNotNull(referenceMap0);
      
      AbstractReferenceMap.ReferenceBaseIterator<AbstractReferenceMap.ReferenceEntry<SequenceInputStream, Object>, InputStream> abstractReferenceMap_ReferenceBaseIterator0 = new AbstractReferenceMap.ReferenceBaseIterator<AbstractReferenceMap.ReferenceEntry<SequenceInputStream, Object>, InputStream>(referenceMap0);
      assertFalse(abstractReferenceMap_ReferenceStrength0.equals((Object)abstractReferenceMap_ReferenceStrength1));
      assertFalse(abstractReferenceMap_ReferenceStrength1.equals((Object)abstractReferenceMap_ReferenceStrength0));
      assertNotNull(abstractReferenceMap_ReferenceBaseIterator0);
      
      AbstractReferenceMap.ReferenceEntry<AbstractReferenceMap.ReferenceEntry<SequenceInputStream, Object>, InputStream> abstractReferenceMap_ReferenceEntry0 = abstractReferenceMap_ReferenceBaseIterator0.currentEntry();
      assertFalse(abstractReferenceMap_ReferenceStrength0.equals((Object)abstractReferenceMap_ReferenceStrength1));
      assertFalse(abstractReferenceMap_ReferenceStrength1.equals((Object)abstractReferenceMap_ReferenceStrength0));
      assertNull(abstractReferenceMap_ReferenceEntry0);
      assertNotSame(abstractReferenceMap_ReferenceStrength0, abstractReferenceMap_ReferenceStrength1);
      assertNotSame(abstractReferenceMap_ReferenceStrength1, abstractReferenceMap_ReferenceStrength0);
      
      AbstractReferenceMap.ReferenceStrength abstractReferenceMap_ReferenceStrength2 = AbstractReferenceMap.ReferenceStrength.SOFT;
      AbstractReferenceMap.ReferenceStrength abstractReferenceMap_ReferenceStrength3 = AbstractReferenceMap.ReferenceStrength.HARD;
      ReferenceIdentityMap<Integer, SoftReference<Object>> referenceIdentityMap0 = new ReferenceIdentityMap<Integer, SoftReference<Object>>(abstractReferenceMap_ReferenceStrength2, abstractReferenceMap_ReferenceStrength3, 0, 2465.6262F);
      assertFalse(abstractReferenceMap_ReferenceStrength2.equals((Object)abstractReferenceMap_ReferenceStrength0));
      assertFalse(abstractReferenceMap_ReferenceStrength2.equals((Object)abstractReferenceMap_ReferenceStrength3));
      assertFalse(abstractReferenceMap_ReferenceStrength3.equals((Object)abstractReferenceMap_ReferenceStrength2));
      assertFalse(abstractReferenceMap_ReferenceStrength3.equals((Object)abstractReferenceMap_ReferenceStrength0));
      assertFalse(abstractReferenceMap_ReferenceStrength3.equals((Object)abstractReferenceMap_ReferenceStrength1));
      assertNotNull(referenceIdentityMap0);
      
      Integer integer0 = new Integer(0);
      assertNotNull(integer0);
      assertEquals(0, (int)integer0);
      
      // Undeclared exception!
      try { 
        referenceIdentityMap0.put(integer0, (SoftReference<Object>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // null values not allowed
         //
         verifyException("org.apache.commons.collections4.map.AbstractReferenceMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test28()  throws Throwable  {
      AbstractReferenceMap.ReferenceStrength abstractReferenceMap_ReferenceStrength0 = AbstractReferenceMap.ReferenceStrength.WEAK;
      AbstractReferenceMap.ReferenceStrength abstractReferenceMap_ReferenceStrength1 = AbstractReferenceMap.ReferenceStrength.WEAK;
      ReferenceIdentityMap<AbstractMap.SimpleImmutableEntry<Object, String>, Integer> referenceIdentityMap0 = new ReferenceIdentityMap<AbstractMap.SimpleImmutableEntry<Object, String>, Integer>(abstractReferenceMap_ReferenceStrength0, abstractReferenceMap_ReferenceStrength1, 0, 266.1F, true);
      assertNotNull(referenceIdentityMap0);
      
      AbstractReferenceMap.ReferenceMapIterator<AbstractMap.SimpleImmutableEntry<Object, String>, Integer> abstractReferenceMap_ReferenceMapIterator0 = new AbstractReferenceMap.ReferenceMapIterator<AbstractMap.SimpleImmutableEntry<Object, String>, Integer>(referenceIdentityMap0);
      assertNotNull(abstractReferenceMap_ReferenceMapIterator0);
      
      // Undeclared exception!
      try { 
        abstractReferenceMap_ReferenceMapIterator0.next();
        fail("Expecting exception: NoSuchElementException");
      
      } catch(NoSuchElementException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.apache.commons.collections4.map.AbstractReferenceMap$ReferenceBaseIterator", e);
      }
  }

  @Test(timeout = 4000)
  public void test29()  throws Throwable  {
      ReferenceMap<Object, PhantomReference<Object>> referenceMap0 = new ReferenceMap<Object, PhantomReference<Object>>();
      assertNotNull(referenceMap0);
      
      ReferenceIdentityMap<PhantomReference<Object>, Integer> referenceIdentityMap0 = new ReferenceIdentityMap<PhantomReference<Object>, Integer>();
      assertNotNull(referenceIdentityMap0);
      
      referenceIdentityMap0.purgeBeforeWrite();
      Integer integer0 = referenceIdentityMap0.remove((Object) referenceMap0);
      assertNull(integer0);
      
      AbstractReferenceMap.ReferenceStrength abstractReferenceMap_ReferenceStrength0 = AbstractReferenceMap.ReferenceStrength.SOFT;
      AbstractReferenceMap.ReferenceStrength abstractReferenceMap_ReferenceStrength1 = AbstractReferenceMap.ReferenceStrength.HARD;
      ReferenceIdentityMap<PhantomReference<Integer>, Object> referenceIdentityMap1 = new ReferenceIdentityMap<PhantomReference<Integer>, Object>(abstractReferenceMap_ReferenceStrength0, abstractReferenceMap_ReferenceStrength1, 41, 99.817F);
      assertFalse(abstractReferenceMap_ReferenceStrength0.equals((Object)abstractReferenceMap_ReferenceStrength1));
      assertFalse(abstractReferenceMap_ReferenceStrength1.equals((Object)abstractReferenceMap_ReferenceStrength0));
      assertNotNull(referenceIdentityMap1);
      
      Integer integer1 = new Integer(0);
      assertNotNull(integer1);
      assertEquals(0, (int)integer1);
      
      int int0 = referenceIdentityMap1.hash(integer1);
      assertFalse(abstractReferenceMap_ReferenceStrength0.equals((Object)abstractReferenceMap_ReferenceStrength1));
      assertFalse(abstractReferenceMap_ReferenceStrength1.equals((Object)abstractReferenceMap_ReferenceStrength0));
      assertEquals(4, int0);
      assertNotSame(abstractReferenceMap_ReferenceStrength0, abstractReferenceMap_ReferenceStrength1);
      assertNotSame(abstractReferenceMap_ReferenceStrength1, abstractReferenceMap_ReferenceStrength0);
      
      ReferenceMap<AbstractMap.SimpleEntry<Object, Integer>, Integer> referenceMap1 = new ReferenceMap<AbstractMap.SimpleEntry<Object, Integer>, Integer>();
      assertNotNull(referenceMap1);
      
      Set<Map.Entry<AbstractMap.SimpleEntry<Object, Integer>, Integer>> set0 = (Set<Map.Entry<AbstractMap.SimpleEntry<Object, Integer>, Integer>>)referenceMap1.entrySet();
      assertNotNull(set0);
      assertTrue(set0.isEmpty());
      assertEquals(0, set0.size());
      
      ReferenceIdentityMap<Object, String> referenceIdentityMap2 = new ReferenceIdentityMap<Object, String>();
      assertNotNull(referenceIdentityMap2);
      
      MapIterator<Object, String> mapIterator0 = referenceIdentityMap2.mapIterator();
      assertNotNull(mapIterator0);
      assertFalse(mapIterator0.hasNext());
      
      AbstractReferenceMap.ReferenceStrength abstractReferenceMap_ReferenceStrength2 = AbstractReferenceMap.ReferenceStrength.SOFT;
      ReferenceMap<PhantomReference<Object>, String> referenceMap2 = new ReferenceMap<PhantomReference<Object>, String>(abstractReferenceMap_ReferenceStrength2, abstractReferenceMap_ReferenceStrength1, 4, 2435.72F, true);
      assertFalse(abstractReferenceMap_ReferenceStrength1.equals((Object)abstractReferenceMap_ReferenceStrength0));
      assertFalse(abstractReferenceMap_ReferenceStrength1.equals((Object)abstractReferenceMap_ReferenceStrength2));
      assertFalse(abstractReferenceMap_ReferenceStrength2.equals((Object)abstractReferenceMap_ReferenceStrength1));
      assertNotNull(referenceMap2);
      
      AbstractHashedMap.HashEntry<PhantomReference<Object>, String> abstractHashedMap_HashEntry0 = referenceMap2.getEntry((Object) null);
      assertFalse(abstractReferenceMap_ReferenceStrength1.equals((Object)abstractReferenceMap_ReferenceStrength0));
      assertFalse(abstractReferenceMap_ReferenceStrength1.equals((Object)abstractReferenceMap_ReferenceStrength2));
      assertFalse(abstractReferenceMap_ReferenceStrength2.equals((Object)abstractReferenceMap_ReferenceStrength1));
      assertNull(abstractHashedMap_HashEntry0);
      assertNotSame(abstractReferenceMap_ReferenceStrength1, abstractReferenceMap_ReferenceStrength0);
      assertNotSame(abstractReferenceMap_ReferenceStrength1, abstractReferenceMap_ReferenceStrength2);
      assertNotSame(abstractReferenceMap_ReferenceStrength2, abstractReferenceMap_ReferenceStrength1);
      assertSame(abstractReferenceMap_ReferenceStrength2, abstractReferenceMap_ReferenceStrength0);
  }

  @Test(timeout = 4000)
  public void test30()  throws Throwable  {
      AbstractReferenceMap.ReferenceStrength abstractReferenceMap_ReferenceStrength0 = AbstractReferenceMap.ReferenceStrength.HARD;
      ReferenceMap<InputStream, String> referenceMap0 = new ReferenceMap<InputStream, String>(abstractReferenceMap_ReferenceStrength0, abstractReferenceMap_ReferenceStrength0, 1, 1, false);
      assertNotNull(referenceMap0);
      
      String string0 = referenceMap0.remove((Object) abstractReferenceMap_ReferenceStrength0);
      assertNull(string0);
      
      ReferenceMap<String, String> referenceMap1 = new ReferenceMap<String, String>(abstractReferenceMap_ReferenceStrength0, abstractReferenceMap_ReferenceStrength0);
      assertNotNull(referenceMap1);
      
      String string1 = referenceMap1.get(abstractReferenceMap_ReferenceStrength0);
      assertNull(string1);
  }

  @Test(timeout = 4000)
  public void test31()  throws Throwable  {
      ReferenceMap<Integer, WeakReference<String>> referenceMap0 = new ReferenceMap<Integer, WeakReference<String>>();
      assertNotNull(referenceMap0);
      
      Integer integer0 = new Integer(0);
      assertNotNull(integer0);
      assertEquals(0, (int)integer0);
      
      String string0 = "z\\DFPMF`bRi";
      WeakReference<String> weakReference0 = new WeakReference<String>("zDFPMF`bRi");
      assertNotNull(weakReference0);
      assertFalse(weakReference0.isEnqueued());
      
      int int0 = (-4226);
      Integer integer1 = new Integer((-4226));
      assertTrue(integer1.equals((Object)int0));
      assertFalse(integer1.equals((Object)integer0));
      assertNotNull(integer1);
      assertEquals((-4226), (int)integer1);
      
      WeakReference<String> weakReference1 = referenceMap0.put(integer1, weakReference0);
      assertTrue(integer1.equals((Object)int0));
      assertFalse(integer1.equals((Object)integer0));
      assertNull(weakReference1);
      assertFalse(weakReference0.isEnqueued());
      
      WeakReference<String> weakReference2 = referenceMap0.put(integer0, weakReference0);
      assertFalse(integer0.equals((Object)integer1));
      assertFalse(integer0.equals((Object)int0));
      assertNull(weakReference2);
      assertFalse(weakReference0.isEnqueued());
      
      AbstractReferenceMap.ReferenceMapIterator<Integer, WeakReference<String>> abstractReferenceMap_ReferenceMapIterator0 = new AbstractReferenceMap.ReferenceMapIterator<Integer, WeakReference<String>>(referenceMap0);
      assertNotNull(abstractReferenceMap_ReferenceMapIterator0);
      
      AbstractReferenceMap.ReferenceStrength abstractReferenceMap_ReferenceStrength0 = AbstractReferenceMap.ReferenceStrength.HARD;
      AbstractReferenceMap.ReferenceStrength abstractReferenceMap_ReferenceStrength1 = AbstractReferenceMap.ReferenceStrength.WEAK;
      ReferenceMap<String, AbstractMap.SimpleEntry<Object, Object>> referenceMap1 = new ReferenceMap<String, AbstractMap.SimpleEntry<Object, Object>>(abstractReferenceMap_ReferenceStrength0, abstractReferenceMap_ReferenceStrength1);
      assertFalse(abstractReferenceMap_ReferenceStrength0.equals((Object)abstractReferenceMap_ReferenceStrength1));
      assertFalse(abstractReferenceMap_ReferenceStrength1.equals((Object)abstractReferenceMap_ReferenceStrength0));
      assertNotNull(referenceMap1);
      
      referenceMap1.purge((Reference<?>) null);
      assertFalse(abstractReferenceMap_ReferenceStrength0.equals((Object)abstractReferenceMap_ReferenceStrength1));
      assertFalse(abstractReferenceMap_ReferenceStrength1.equals((Object)abstractReferenceMap_ReferenceStrength0));
      assertNotSame(abstractReferenceMap_ReferenceStrength0, abstractReferenceMap_ReferenceStrength1);
      assertNotSame(abstractReferenceMap_ReferenceStrength1, abstractReferenceMap_ReferenceStrength0);
      
      AbstractHashedMap<AbstractMap.SimpleImmutableEntry<String, Object>, SequenceInputStream> abstractHashedMap0 = new AbstractHashedMap<AbstractMap.SimpleImmutableEntry<String, Object>, SequenceInputStream>();
      assertNotNull(abstractHashedMap0);
      assertTrue(abstractHashedMap0.isEmpty());
      
      Iterator<SequenceInputStream> iterator0 = abstractHashedMap0.createValuesIterator();
      assertNotNull(iterator0);
      assertTrue(abstractHashedMap0.isEmpty());
      
      AbstractReferenceMap.ReferenceEntrySet<AbstractMap.SimpleImmutableEntry<String, Object>, SequenceInputStream> abstractReferenceMap_ReferenceEntrySet0 = new AbstractReferenceMap.ReferenceEntrySet<AbstractMap.SimpleImmutableEntry<String, Object>, SequenceInputStream>(abstractHashedMap0);
      assertNotNull(abstractReferenceMap_ReferenceEntrySet0);
      assertTrue(abstractHashedMap0.isEmpty());
      
      Object[] objectArray0 = abstractReferenceMap_ReferenceEntrySet0.toArray();
      assertEquals(0, objectArray0.length);
      assertNotNull(objectArray0);
      assertTrue(abstractHashedMap0.isEmpty());
      
      AbstractReferenceMap.ReferenceStrength abstractReferenceMap_ReferenceStrength2 = AbstractReferenceMap.ReferenceStrength.HARD;
      AbstractReferenceMap.ReferenceStrength abstractReferenceMap_ReferenceStrength3 = AbstractReferenceMap.ReferenceStrength.HARD;
      ReferenceIdentityMap<String, PhantomReference<InputStream>> referenceIdentityMap0 = null;
      try {
        referenceIdentityMap0 = new ReferenceIdentityMap<String, PhantomReference<InputStream>>(abstractReferenceMap_ReferenceStrength2, abstractReferenceMap_ReferenceStrength3, 0, (-4226));
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Load factor must be greater than 0
         //
         verifyException("org.apache.commons.collections4.map.AbstractHashedMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test32()  throws Throwable  {
      AbstractReferenceMap.ReferenceValues<WeakReference<String>> abstractReferenceMap_ReferenceValues0 = new AbstractReferenceMap.ReferenceValues<WeakReference<String>>((AbstractHashedMap<?, WeakReference<String>>) null);
      assertNotNull(abstractReferenceMap_ReferenceValues0);
      
      String string0 = "org.apache.commons.collections4.map.ReferenceMap";
      WeakReference<String> weakReference0 = new WeakReference<String>("org.apache.commons.collections4.map.ReferenceMap");
      assertNotNull(weakReference0);
      assertFalse(weakReference0.isEnqueued());
      
      // Undeclared exception!
      try { 
        abstractReferenceMap_ReferenceValues0.add(weakReference0);
        fail("Expecting exception: UnsupportedOperationException");
      
      } catch(UnsupportedOperationException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("java.util.AbstractCollection", e);
      }
  }

  @Test(timeout = 4000)
  public void test33()  throws Throwable  {
      ReferenceIdentityMap<AbstractReferenceMap.ReferenceEntry<Object, String>, Object> referenceIdentityMap0 = new ReferenceIdentityMap<AbstractReferenceMap.ReferenceEntry<Object, String>, Object>();
      assertNotNull(referenceIdentityMap0);
      
      boolean boolean0 = referenceIdentityMap0.isEmpty();
      assertTrue(boolean0);
      
      AbstractReferenceMap.ReferenceKeySetIterator<AbstractReferenceMap.ReferenceEntry<Object, String>> abstractReferenceMap_ReferenceKeySetIterator0 = new AbstractReferenceMap.ReferenceKeySetIterator<AbstractReferenceMap.ReferenceEntry<Object, String>>(referenceIdentityMap0);
      assertNotNull(abstractReferenceMap_ReferenceKeySetIterator0);
      
      ReferenceMap<Object, PhantomReference<String>> referenceMap0 = new ReferenceMap<Object, PhantomReference<String>>();
      assertNotNull(referenceMap0);
      
      String string0 = "fze1 ~!/j~X";
      ReferenceQueue<String> referenceQueue0 = new ReferenceQueue<String>();
      assertNotNull(referenceQueue0);
      
      PhantomReference<String> phantomReference0 = new PhantomReference<String>("fze1 ~!/j~X", referenceQueue0);
      assertNotNull(phantomReference0);
      assertFalse(phantomReference0.isEnqueued());
      
      phantomReference0.clear();
      assertFalse(phantomReference0.isEnqueued());
      
      PhantomReference<String> phantomReference1 = referenceMap0.put(referenceIdentityMap0, phantomReference0);
      assertNull(phantomReference1);
      assertFalse(phantomReference0.isEnqueued());
      
      Object object0 = null;
      AbstractReferenceMap.ReferenceStrength abstractReferenceMap_ReferenceStrength0 = AbstractReferenceMap.ReferenceStrength.SOFT;
      AbstractReferenceMap.ReferenceStrength abstractReferenceMap_ReferenceStrength1 = AbstractReferenceMap.ReferenceStrength.HARD;
      ReferenceIdentityMap<Object, String> referenceIdentityMap1 = new ReferenceIdentityMap<Object, String>(abstractReferenceMap_ReferenceStrength0, abstractReferenceMap_ReferenceStrength1, false);
      assertFalse(abstractReferenceMap_ReferenceStrength0.equals((Object)abstractReferenceMap_ReferenceStrength1));
      assertFalse(abstractReferenceMap_ReferenceStrength1.equals((Object)abstractReferenceMap_ReferenceStrength0));
      assertNotNull(referenceIdentityMap1);
      
      AbstractReferenceMap.ReferenceMapIterator<Object, String> abstractReferenceMap_ReferenceMapIterator0 = new AbstractReferenceMap.ReferenceMapIterator<Object, String>(referenceIdentityMap1);
      assertFalse(abstractReferenceMap_ReferenceStrength0.equals((Object)abstractReferenceMap_ReferenceStrength1));
      assertFalse(abstractReferenceMap_ReferenceStrength1.equals((Object)abstractReferenceMap_ReferenceStrength0));
      assertNotNull(abstractReferenceMap_ReferenceMapIterator0);
      
      AbstractReferenceMap.ReferenceEntry<Object, String> abstractReferenceMap_ReferenceEntry0 = abstractReferenceMap_ReferenceMapIterator0.entry;
      assertNull(abstractReferenceMap_ReferenceEntry0);
      
      // Undeclared exception!
      try { 
        referenceIdentityMap0.put((AbstractReferenceMap.ReferenceEntry<Object, String>) null, referenceIdentityMap1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // null keys not allowed
         //
         verifyException("org.apache.commons.collections4.map.AbstractReferenceMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test34()  throws Throwable  {
      AbstractReferenceMap.ReferenceStrength abstractReferenceMap_ReferenceStrength0 = AbstractReferenceMap.ReferenceStrength.HARD;
      ReferenceIdentityMap<SoftReference<Integer>, String> referenceIdentityMap0 = new ReferenceIdentityMap<SoftReference<Integer>, String>(abstractReferenceMap_ReferenceStrength0, abstractReferenceMap_ReferenceStrength0, true);
      assertNotNull(referenceIdentityMap0);
      
      AbstractReferenceMap.ReferenceKeySetIterator<SoftReference<Integer>> abstractReferenceMap_ReferenceKeySetIterator0 = new AbstractReferenceMap.ReferenceKeySetIterator<SoftReference<Integer>>(referenceIdentityMap0);
      assertNotNull(abstractReferenceMap_ReferenceKeySetIterator0);
  }

  @Test(timeout = 4000)
  public void test35()  throws Throwable  {
      ReferenceIdentityMap<String, String> referenceIdentityMap0 = new ReferenceIdentityMap<String, String>();
      assertNotNull(referenceIdentityMap0);
      
      Iterator<Map.Entry<String, String>> iterator0 = (Iterator<Map.Entry<String, String>>)referenceIdentityMap0.createEntrySetIterator();
      assertNotNull(iterator0);
      
      int int0 = referenceIdentityMap0.size();
      assertEquals(0, int0);
      
      Set<Map.Entry<String, String>> set0 = (Set<Map.Entry<String, String>>)referenceIdentityMap0.entrySet();
      assertNotNull(set0);
      assertTrue(set0.isEmpty());
      assertEquals(0, set0.size());
      
      AbstractReferenceMap.ReferenceStrength abstractReferenceMap_ReferenceStrength0 = AbstractReferenceMap.ReferenceStrength.WEAK;
      ReferenceMap<String, Object> referenceMap0 = new ReferenceMap<String, Object>(abstractReferenceMap_ReferenceStrength0, abstractReferenceMap_ReferenceStrength0, 0, 555.0F);
      assertNotNull(referenceMap0);
      
      Iterator<Map.Entry<String, Object>> iterator1 = (Iterator<Map.Entry<String, Object>>)referenceMap0.createEntrySetIterator();
      assertNotNull(iterator1);
  }

  @Test(timeout = 4000)
  public void test36()  throws Throwable  {
      ReferenceMap<AbstractReferenceMap.ReferenceEntry<Integer, Integer>, Integer> referenceMap0 = new ReferenceMap<AbstractReferenceMap.ReferenceEntry<Integer, Integer>, Integer>();
      assertNotNull(referenceMap0);
      
      Collection<Integer> collection0 = referenceMap0.values();
      assertNotNull(collection0);
      
      ReferenceMap<Integer, Integer> referenceMap1 = new ReferenceMap<Integer, Integer>();
      assertNotNull(referenceMap1);
      
      Integer integer0 = new Integer((-1160));
      assertNotNull(integer0);
      assertEquals((-1160), (int)integer0);
      
      AbstractReferenceMap.ReferenceEntry<Integer, Integer> abstractReferenceMap_ReferenceEntry0 = new AbstractReferenceMap.ReferenceEntry<Integer, Integer>(referenceMap1, (AbstractHashedMap.HashEntry<Integer, Integer>) null, (-1160), integer0, integer0);
      assertNotNull(abstractReferenceMap_ReferenceEntry0);
      
      AbstractReferenceMap.ReferenceEntry<Integer, Integer> abstractReferenceMap_ReferenceEntry1 = abstractReferenceMap_ReferenceEntry0.next();
      assertNull(abstractReferenceMap_ReferenceEntry1);
      
      Integer integer1 = new Integer(1158);
      assertFalse(integer1.equals((Object)integer0));
      assertNotNull(integer1);
      assertEquals(1158, (int)integer1);
      
      // Undeclared exception!
      try { 
        referenceMap0.put((AbstractReferenceMap.ReferenceEntry<Integer, Integer>) null, integer1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // null keys not allowed
         //
         verifyException("org.apache.commons.collections4.map.AbstractReferenceMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test37()  throws Throwable  {
      ReferenceIdentityMap<SequenceInputStream, WeakReference<Integer>> referenceIdentityMap0 = new ReferenceIdentityMap<SequenceInputStream, WeakReference<Integer>>();
      assertNotNull(referenceIdentityMap0);
      
      SequenceInputStream sequenceInputStream0 = null;
      int int0 = (-3819);
      Integer integer0 = new Integer((-3819));
      assertTrue(integer0.equals((Object)int0));
      assertNotNull(integer0);
      assertEquals((-3819), (int)integer0);
      
      ReferenceQueue<Integer> referenceQueue0 = new ReferenceQueue<Integer>();
      assertNotNull(referenceQueue0);
      
      Integer integer1 = new Integer(57);
      assertFalse(integer1.equals((Object)int0));
      assertFalse(integer1.equals((Object)integer0));
      assertNotNull(integer1);
      assertEquals(57, (int)integer1);
      
      AbstractReferenceMap.WeakRef<Integer> abstractReferenceMap_WeakRef0 = new AbstractReferenceMap.WeakRef<Integer>(370, integer1, referenceQueue0);
      assertFalse(integer1.equals((Object)int0));
      assertFalse(integer1.equals((Object)integer0));
      assertNotNull(abstractReferenceMap_WeakRef0);
      assertFalse(abstractReferenceMap_WeakRef0.isEnqueued());
      
      // Undeclared exception!
      try { 
        referenceIdentityMap0.put((SequenceInputStream) null, abstractReferenceMap_WeakRef0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // null keys not allowed
         //
         verifyException("org.apache.commons.collections4.map.AbstractReferenceMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test38()  throws Throwable  {
      AbstractReferenceMap.ReferenceStrength abstractReferenceMap_ReferenceStrength0 = AbstractReferenceMap.ReferenceStrength.SOFT;
      ReferenceMap<Integer, String> referenceMap0 = new ReferenceMap<Integer, String>(abstractReferenceMap_ReferenceStrength0, abstractReferenceMap_ReferenceStrength0, 3321, 3321);
      assertNotNull(referenceMap0);
      
      Integer integer0 = new Integer(4);
      assertNotNull(integer0);
      assertEquals(4, (int)integer0);
      
      String string0 = referenceMap0.put(integer0, "?Y+q(d^]O");
      assertNull(string0);
      
      MapIterator<Integer, String> mapIterator0 = referenceMap0.mapIterator();
      assertNotNull(mapIterator0);
      assertTrue(mapIterator0.hasNext());
      
      boolean boolean0 = referenceMap0.isKeyType(abstractReferenceMap_ReferenceStrength0);
      assertTrue(boolean0);
      
      ReferenceMap<Integer, AbstractReferenceMap.ReferenceEntry<SequenceInputStream, Object>> referenceMap1 = new ReferenceMap<Integer, AbstractReferenceMap.ReferenceEntry<SequenceInputStream, Object>>();
      assertNotNull(referenceMap1);
  }

  @Test(timeout = 4000)
  public void test39()  throws Throwable  {
      AbstractReferenceMap.ReferenceStrength abstractReferenceMap_ReferenceStrength0 = AbstractReferenceMap.ReferenceStrength.WEAK;
      int int0 = (-1);
      ReferenceMap<Integer, String> referenceMap0 = null;
      try {
        referenceMap0 = new ReferenceMap<Integer, String>(abstractReferenceMap_ReferenceStrength0, abstractReferenceMap_ReferenceStrength0, (-1), (-1), true);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Initial capacity must be a non negative number
         //
         verifyException("org.apache.commons.collections4.map.AbstractHashedMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test40()  throws Throwable  {
      AbstractHashedMap<String, Integer> abstractHashedMap0 = new AbstractHashedMap<String, Integer>();
      assertNotNull(abstractHashedMap0);
      assertTrue(abstractHashedMap0.isEmpty());
      
      String string0 = "getValue() can only be called after next() and before remove()";
      Integer integer0 = new Integer((-1512));
      assertNotNull(integer0);
      assertEquals((-1512), (int)integer0);
      
      // Undeclared exception!
      try { 
        abstractHashedMap0.put("getValue() can only be called after next() and before remove()", integer0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.apache.commons.collections4.map.AbstractHashedMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test41()  throws Throwable  {
      AbstractHashedMap<SoftReference<InputStream>, SequenceInputStream> abstractHashedMap0 = new AbstractHashedMap<SoftReference<InputStream>, SequenceInputStream>(0, 0, (-2207));
      assertNotNull(abstractHashedMap0);
      assertTrue(abstractHashedMap0.isEmpty());
      
      MockFileInputStream mockFileInputStream0 = null;
      try {
        mockFileInputStream0 = new MockFileInputStream((String) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.evosuite.runtime.mock.java.io.MockFileInputStream", e);
      }
  }

  @Test(timeout = 4000)
  public void test42()  throws Throwable  {
      AbstractReferenceMap.ReferenceStrength abstractReferenceMap_ReferenceStrength0 = AbstractReferenceMap.ReferenceStrength.SOFT;
      ReferenceIdentityMap<WeakReference<SequenceInputStream>, SoftReference<Object>> referenceIdentityMap0 = new ReferenceIdentityMap<WeakReference<SequenceInputStream>, SoftReference<Object>>(abstractReferenceMap_ReferenceStrength0, abstractReferenceMap_ReferenceStrength0, 2, 2);
      assertNotNull(referenceIdentityMap0);
      
      byte[] byteArray0 = new byte[2];
      byte byte0 = (byte) (-46);
      byteArray0[0] = (byte) (-46);
      byteArray0[1] = (byte) (-123);
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
      assertEquals(2, byteArray0.length);
      assertNotNull(byteArrayInputStream0);
      assertArrayEquals(new byte[] {(byte) (-46), (byte) (-123)}, byteArray0);
      assertEquals(2, byteArrayInputStream0.available());
      
      SequenceInputStream sequenceInputStream0 = new SequenceInputStream(byteArrayInputStream0, byteArrayInputStream0);
      assertEquals(2, byteArray0.length);
      assertNotNull(sequenceInputStream0);
      assertArrayEquals(new byte[] {(byte) (-46), (byte) (-123)}, byteArray0);
      assertEquals(2, byteArrayInputStream0.available());
      
      int int0 = (-1134);
      // Undeclared exception!
      try { 
        sequenceInputStream0.read(byteArray0, (-1134), (int) (byte) (-46));
        fail("Expecting exception: IndexOutOfBoundsException");
      
      } catch(IndexOutOfBoundsException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("java.io.SequenceInputStream", e);
      }
  }

  @Test(timeout = 4000)
  public void test43()  throws Throwable  {
      ReferenceIdentityMap<SoftReference<Object>, Integer> referenceIdentityMap0 = new ReferenceIdentityMap<SoftReference<Object>, Integer>();
      AbstractReferenceMap.ReferenceStrength abstractReferenceMap_ReferenceStrength0 = AbstractReferenceMap.ReferenceStrength.WEAK;
      AbstractReferenceMap.ReferenceStrength abstractReferenceMap_ReferenceStrength1 = AbstractReferenceMap.ReferenceStrength.HARD;
      ReferenceIdentityMap<PhantomReference<Integer>, Integer> referenceIdentityMap1 = new ReferenceIdentityMap<PhantomReference<Integer>, Integer>(abstractReferenceMap_ReferenceStrength0, abstractReferenceMap_ReferenceStrength1, true);
      referenceIdentityMap1.keySet();
      int int0 = 123;
      Integer integer0 = new Integer(123);
      ReferenceQueue<Object> referenceQueue0 = new ReferenceQueue<Object>();
      PhantomReference<Integer> phantomReference0 = new PhantomReference<Integer>(integer0, referenceQueue0);
      referenceQueue0.remove((long) 123);
      int int1 = 1;
      Integer integer1 = new Integer(1);
      referenceIdentityMap1.put(phantomReference0, integer1);
      AbstractReferenceMap.ReferenceBaseIterator<PhantomReference<Integer>, Integer> abstractReferenceMap_ReferenceBaseIterator0 = new AbstractReferenceMap.ReferenceBaseIterator<PhantomReference<Integer>, Integer>(referenceIdentityMap1);
      abstractReferenceMap_ReferenceBaseIterator0.nextEntry();
      ReferenceIdentityMap<String, Integer> referenceIdentityMap2 = new ReferenceIdentityMap<String, Integer>();
      ReferenceMap<String, String> referenceMap0 = new ReferenceMap<String, String>();
      referenceMap0.isEmpty();
      // Undeclared exception!
      try { 
        AbstractReferenceMap.ReferenceStrength.resolve(123);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.apache.commons.collections4.map.AbstractReferenceMap$ReferenceStrength", e);
      }
  }
}
